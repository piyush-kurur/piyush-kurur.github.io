<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <link rel="prev" href="../posts/2013-10-18-Type-theory-series.html" />
    <link rel="next" href="../posts/2014-01-11-Typed-lambda-calculus.html" />
    <meta name="generator" content="pandoc" />
    <link href="//fonts.googleapis.com/css?family=Tangerine:700" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <title>Piyush P Kurur|Lambda calculus</title>
  </head>
  <body>
    <div id="root" class="page">
  <div class="header">
    <h1>Piyush P Kurur</h1>
    <div class="navigation">
      <!-- Add your navigation menu here !-->
<ul>
<li><a href="../" title="Home"><i class="fa fa-home"></i></a></li>
<li><a href="../posts/feeds/atom.xml"><i class="fa fa-rss"></i></a></li>
<li><a href="../contact/" title="Contact"><i class="fa fa-envelope"></i></a></li>
<li><a href="https://github.com/piyush-kurur" title="On GitHub"><i class="fa fa-github"></i></a></li>
<li><a href="https://bitbucket.org/piyush-kurur" title="On BitBucket"><i class="fa fa-bitbucket"></i></a> <!--

[<i class="icon-legal " title="Legalese"/>](/legal/)

[<i class="icon-archive " title="Archive"/>](/posts/archive/)
--></li>
</ul>
    </div>
  </div>
  <div class="main-content">
    <span class="post-tags"><i class="fa fa-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Lambda calculus</h1>
  <span class="post-date">November  4, 2013 (Monday)</span>

  <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent(window.location); return false" alt="submit to reddit" border="0">
    <span class="reddit">
      <i class="fa fa-reddit-square fa-lg"></i> reddit this
    </span>
  </a>
  <br />
    <p>We begin the exploration of type theory by describing lambda calculus. This post is mostly to set up the notation and the standard reference for material here is the encyclopedic book <a href="http://mathgate.info/cebrown/notes/barendregt.php" title="The Lambda Calculus: Its syntax and semantics">The lambda calculus: Its syntax and semantics</a>. Also have a look on <a href="http://en.wikipedia.org/wiki/Lambda_calculus" title="Wikipedia: Lambda calculus">Wikipedia</a> for details and references.</p>
<p>The core idea of lambda calculus is an elegant notation invented by <a href="http://en.wikipedia.org/wiki/Alonzo_Church" title="Wikipedia: Alonzo Church">Alonzo Church</a> to capture functions without naming them. Consider the function that increments its argument by 1. In notation of lambda calculus one can write such an increment function as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">λ x . x + 1</annotation></semantics></math> (assuming of course that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> has already been defined). This notation has now found its way to many programming languages like Haskell (<code>\ x -&gt; x + 1</code> the backslash is an <a href="http://en.wikipedia.org/wiki/ASCII" title="Wikipedia: ASCII">ASCII</a> approximation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>), python (<code>lambda x: x + 1</code>) etc. The lambda calculus we deal with here does not have the <em>built-in</em> function like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>. All it has is a (countably infinite) supply of variables, which we will denote by small case letters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> etc and two fundamental operation namely application and abstraction. The lambda calculus expressions can be inductively defined as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex"> e = x | e_1 e_2 | λ x . e</annotation></semantics></math></p>
<p>In the above inductive definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is any one of the countably infinite variables and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math> are lambda calculus expressions defined recursively. We will follow that standard convention that all application associates to the left (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">f g h</annotation></semantics></math> means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((f g) h)</annotation></semantics></math>) and that application binds tighter than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. Further, the the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λxy.xy</annotation></semantics></math> means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>λ</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx . λy . xy</annotation></semantics></math>.</p>
<h1 id="free-and-bound-variables.">Free and bound variables.</h1>
<p>The lambda abstraction acts like any other mathematical quantifier when it comes to determining the free and bound variables. An occurrence of a variable in a expression is either free (i.e. is not in the scope of any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction) or is bound to a lambda abstraction. If an occurrence of a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is in the scope of more than one <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction then it is bound to the inner most one. For example in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx.xy</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is bound and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> is free. One can define the notion of free variables inductively as follows.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">FV(x)       = \{ x\},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>∪</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">FV(e_1 e_2) = FV(e_1) ∪ FV(e_2),</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>∖</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">FV(λx . e)  = FV(e) ∖ \{x \}.</annotation></semantics></math></p>
<p>As in other mathematical notations, the meaning of a lambda calculus expression depends only on the free variables, which means one can change the bound variables of an expression. For example the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx . xy</annotation></semantics></math> is the same as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>t</mi><mi>.</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λt. t y</annotation></semantics></math>. This change of bound variables is called <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion. When doing an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion however, care must be taken to avoid variable bindings to be inadvertently changed. For example in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx.xy</annotation></semantics></math>, the variable x cannot be changed to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> as it is occurs free and changing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> will make it bound. One can avoid such a situation if we always use fresh variables. We will assume from now on that all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion takes care of this problem.</p>
<h1 id="β-reductions"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions</h1>
<p>The computational power of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus comes from what is known as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions which formalises the notion of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. The essence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction is that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">(λx. M)N</annotation></semantics></math>, under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction, reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> is the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> with all <em>free</em> occurrences of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> replaced by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>. However, we have to be careful to take care that no free variable in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> gets inadvertently bound as a result. For example consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">M = λy.xy</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">N=y</annotation></semantics></math>. If we blindly reduce <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">(λx.M) N</annotation></semantics></math> then the free variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> gets bound. This is because a free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> comes in the scope of a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λy</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> happens to be free in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>. To avoid this problem one can <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-convert the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> to use a new bound variable instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>. We assume from now on that each such <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction carefully avoids the free variable capture.</p>
<p>A <em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-normal form</em> is an expression for which there are no more <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions possible. For example a variable is a normal form so is expressions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λx.x</annotation></semantics></math>. One can think of this as a program that has terminated. We say that an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> <em>has</em> a normal form if there is normal form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> to which it can be reduced after a series of finitely many <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions. Expressions might have a normal form or can diverge and it is <em>undecidable</em> to check which is the case. However, a consequence of the <a href="http://en.wikipedia.org/wiki/Church-Rosser_theorem" title="Wikipedia: Church-Rosser theorem">Church-Rosser theorem</a> is that if an expression has a normal form then it should be unique.</p>
<p>A <em>reduction strategy</em> is an algorithm to choose which sub-term of a lambda calculus expression should be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduced next. Clearly there is no strategy that will terminate always as there are terms which do not have a normal form. Can we have a strategy which will guarantee termination if the expression has a normal form? Fortunately the <em>normal order</em> evaluation strategy is normalising, i.e. it finds a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-normal form if it exists (See <a href="http://en.wikipedia.org/wiki/Lambda_Calculus" title="Wikipedia: Lambda Calculus">Lambda Calculus</a> for more details). Therefore, the problem of finding the normal form is <em>partially recursive</em> in the sense that one can write a program to compute the normal form of an expression if it has one.</p>
<h1 id="fixed-points-and-recursion">Fixed points and recursion</h1>
<p>It might not appear so but hidden inside the simplicity of lambda calculus is a full fledged programming language. With appropriate encoding of natural numbers (see for example <a href="http://en.wikipedia.org/wiki/Church_encoding" title="Wikipedia: Church encoding">Church encoding</a>) one can represent all computable functions. This is the Church-Turing hypothesis. While we do not want to go into the details of this, we will show how to implement one important feature namely recursive definition of functions.</p>
<p>An important property of untyped lambda calculus is that every lambda calculus function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> has a <em>fixed point</em>: given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>, consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X = λx. F(xx)</annotation></semantics></math>. One can easily show that the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">XX</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F(XX)</annotation></semantics></math> and is therefore the fixed point of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. Furthermore, the computation of fixed point is effective as well, i.e. we have a lambda calculus combinator for computing it: Consider for example the combinator (i.e. lambda calculus term with no free variable) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> defined as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Y = λf . (λx . f(xx))(λx. f(xx))</annotation></semantics></math> It is easy to verify that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">YF</annotation></semantics></math> is the fixed point for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. Existence of fixed point combinator is important as that is what allows us to define functions recursively. A recursive definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f = F(f)</annotation></semantics></math> is nothing but the fixed point of the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. The fact that it is effective make it possible for the compiler to support recursive functions. Fixed point theorem also allows mutual recursion. For this one has to have a way of <em>pairing</em> values into tuples which can be done in lambda calculus by suitable encoding (see the <a href="http://en.wikipedia.org/wiki/Lambda_calculus#Pairs" title="Wikipedia: Lambda calculus#Pairs">Lambda calculus#Pairs</a>). The reset of the details I leave it as an exercise.</p>
</div>

<div class="post-comments">
  <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2013-11-04-Lambda-calculus.html';
                          // The url of this page
  var disqus_title      = 'Lambda calculus';      // The title of this post
  var disqus_identifier = '2013-11-04-Lambda-calculus';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="fa fa-flag"></i> Fontawesome</a>
</div>

  </body>
</html>
