<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <link rel="prev" href="../posts/2013-11-04-Lambda-calculus.html" />
    <link rel="next" href="../posts/2014-08-27-Dependent-Types.html" />
    <meta name="generator" content="pandoc" />
    <link href="//fonts.googleapis.com/css?family=Tangerine:700" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <title>Piyush P Kurur|Typed lambda calculus</title>
  </head>
  <body>
    <div id="root" class="page">
  <div class="header">
    <h1>Piyush P Kurur</h1>
    <div class="navigation">
      <!-- Add your navigation menu here !-->
<ul>
<li><a href="../" title="Home"><i class="fa fa-home"></i></a></li>
<li><a href="../posts/feeds/atom.xml"><i class="fa fa-rss"></i></a></li>
<li><a href="../contact/" title="Contact"><i class="fa fa-envelope"></i></a></li>
<li><a href="https://github.com/piyush-kurur" title="On GitHub"><i class="fa fa-github"></i></a></li>
<li><a href="https://bitbucket.org/piyush-kurur" title="On BitBucket"><i class="fa fa-bitbucket"></i></a> <!--

[<i class="icon-legal " title="Legalese"/>](/legal/)

[<i class="icon-archive " title="Archive"/>](/posts/archive/)
--></li>
</ul>
    </div>
  </div>
  <div class="main-content">
    <span class="post-tags"><i class="fa fa-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Typed lambda calculus</h1>
  <span class="post-date">January 11, 2014 (Saturday)</span>

  <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent(window.location); return false" alt="submit to reddit" border="0">
    <span class="reddit">
      <i class="fa fa-reddit-square fa-lg"></i> reddit this
    </span>
  </a>
  <br />
    <h2 id="in-memory-of-sanjeev-kumar-aggarwal-skaska.">In memory of <a href="http://cse.iitk.ac.in/users/ska" title="Sanjeev Kumar Aggarwal">Sanjeev Kumar Aggarwal (ska)</a>.</h2>
<p><strong>Update</strong>: An implementation of propositional logic in agada is available on my github repository <a href="https://github.com/piyush-kurur/sample-code/blob/master/agda/Logic.agda">sample-code/agda/Logic.agda</a></p>
<p>In this post, I briefly introduce typed lambda calculus in its simplest form and explain the type inference rules. The <a href="http://en.wikipedia.org/wiki/Curry-Howard_correspndence" title="Wikipedia: Curry-Howard correspndence">Curry-Howard isomorphism</a> appears for the first time here, although only for propositional logic.</p>
<h1 id="what-are-types">What are types ?</h1>
<p>We fix a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> of base types that can be thought of as the <em>built-in</em> types of the language. For this post, the set of types are all terms generated inductively as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex"> τ ≔ t ∈ 𝒯  | τ_1 → τ_2.</annotation></semantics></math></p>
<p>The above inductive definition means that a type is either a basic type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, i.e. an element of the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math>, or it is the function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> are themselves types. The type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> captures the type of functions whose domain is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and range is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. There are few points that we want to clarify right away.</p>
<ol style="list-style-type: decimal">
<li><p>Consider the set of propositional logic formulas where the base set of propositions is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and the only logical connective is the logical implies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. There is a one-to-one correspondence with types of our language: interpret the functional type symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math> as the implication operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. We will see in this post that this connection is <em>not</em> just skin deep.</p></li>
<li><p>The types in our language are defined independent of the terms in our lambda calculus. While this is possible for the version of typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus that we define here, when we want more powerful types this will no more be possible. We will have to define the values and types together.</p></li>
</ol>
<h1 id="what-is-a-well-typed-expression">What is a well typed expression ?</h1>
<p>Intuitively, a typed lambda calculus is a version of lambda calculus where each expression is assigned a <em>type</em>. This type is used to ensure that function application is of the correct type, i.e. whenever an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> is applied on another expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> <em>should be</em> a function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">τ → τ′</annotation></semantics></math>, for type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">τ′</annotation></semantics></math>. This requires us to assign types to lambda calculus terms in a systematic way. We use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> to assert that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Recall that a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term is a variable, or an application or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. Therefore, we need to give systematic rules for assigning types for these three cases.</p>
<p>The base case would be to assign types to variables in an expression. We ensure that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction also have to assert the type of the variable it quantifies. Thus, any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction is of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x:τ. e</annotation></semantics></math> and the bound variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> gets its type from this abstractions, i.e. every free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is assumed to be having the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. For the free variables, the only way we can have types is by <em>type assumptions</em>, a set of assertions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">x : τ</annotation></semantics></math>. The type of an expression thus depends on the type of the free variables in it. Therefore, a well typed lambda calculus expression should be a combination of an expression and a set of type assumption for the free variables in it. Furthermore, they should satisfy some additional rules which we call the <em>type inference rules</em>.</p>
<p>A <em>well typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression</em> is an ordered pair of (1) a type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> together with (2) a typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math>, written in the logical style <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e:τ</annotation></semantics></math>, subject to the following inference rules:</p>
<p>Variable Rule (<strong>VAR</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{}{Γ \cup \{ x : τ\} ⊢ x : τ}.</annotation></semantics></math></p>
<p>Rule for application (<strong>APP</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ f : τ_1 → τ_2;\;\; Γ ⊢ e : τ_1}{ Γ ⊢ f e : τ_2}.</annotation></semantics></math></p>
<p>Rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction (<strong>ABS</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ \cup \{x : τ_1\} ⊢ e : τ_2}{Γ ⊢ (λ x : τ_1 . e) : τ_1
	→ τ_2}.</annotation></semantics></math></p>
<p>The notation that we used for defining well typed terms is like a set of logical deduction rules. The stuff on the top of the horizontal line are <em>pre-conditions</em>, i.e. stuff which we already have derived, and the stuff in the bottom are <em>consequences</em>. i.e. stuff that can be concluded given the pre-conditions on the top. Let us now interpret each of these rules informally:</p>
<p><strong>VAR</strong> : This rule states that with no pre-conditions we can derive the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">x: τ</annotation></semantics></math> provided it is already an assumption. This rule takes care of the free variables in the expression.</p>
<p><strong>APP</strong> : This is the rules that makes sure that the functions are applied to the right arguments. It makes sure of two things (1) We are allowed to form the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> under the type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> if and only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> have types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> respectively under the assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> and (2) then the resulting expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p><strong>ABS</strong> : This rules assign types to the bound variables. This rule needs a bit of getting used to as we normally think in the other direction, i.e. in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x : τ_1 . e</annotation></semantics></math>, the occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math>.</p>
<p>In all the above rules, we assume that the type assumptions that arise on the left hand side of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊢</mo><annotation encoding="application/x-tex">⊢</annotation></semantics></math> symbol satisfies some obvious conditions like, no variables should have two distinct type assumptions etc.</p>
<h1 id="curry-howard-isomorphism.">Curry-Howard isomorphism.</h1>
<p>Recall that any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> can be seen as a proposition over the set of basic proportion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> by interpreting the function type operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math> as the Boolean implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. Consider the three type inference rules that we discussed and replace any type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">x : σ</annotation></semantics></math> or type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e : τ</annotation></semantics></math> in the rules above with just the associated proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> respectively. This gives a set of inference rules for a restricted form of propositional logic that has implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math> as the only Boolean operator. This isomorphism between type inference and logical inference rules is often called the Curry-Howard isomorphism and is one of the main ideas of type theory. The goal in the rest of the post is to give a different interpretation of typed lambda calculus so that some magic is removed out of this isomorphism.</p>
<p>Consider the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math>. Normally, we think of types as a subset of allowed values and the assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> as saying that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a value in the set associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. There is an alternate interpretation which makes the logical connection easy to make. Think of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> as a logical statement, proposition in this case. An assertion of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e: τ</annotation></semantics></math> is thought of as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> being the proof of the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Alternatively, we think of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> as the set of all proofs of the proposition associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> in which case our usual interpretation means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In this interpretation, a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> should be treated a method to convert proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> to proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. This then gives a valid interpretation of all the rules of type inference as rules of building proofs.</p>
<p><strong>VAR</strong> : We can create a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> if we have such a proof by one of the assumption.</p>
<p><strong>APP</strong> : If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> then it is a function that converts proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. If in addition, we have a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math>, we can apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to it and get the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>.</p>
<p><strong>ABS</strong> : If assuming a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> we were able to get a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> (which can make use of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> as an axiom) of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> then the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x: τ_1 . e</annotation></semantics></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> as it takes any input proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and produces as output the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>:=</mo><mi>p</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">e[x := p]</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>:=</mo><mi>p</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">e[x := p]</annotation></semantics></math> denotes replacing all free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</p>
<p>This essentially is the crux of the “types as proofs” view point. If we want to effectively use this logical content of type theory, we need to look at richer and richer types and that is what we would be doing. We make some modest enriching in this post and leave the rest for future posts.</p>
<h2 id="introductionelimination-rules.">Introduction/Elimination rules.</h2>
<p>For the logical operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math>, the <strong>ABS</strong> rule serves as the <em>introduction</em> rule as its post-condition is an implication. Any proof of a formula that is essentially an implication therefore would have <strong>ABS</strong> as its last step. On the other hand <strong>APP</strong> serves the dual purpose. It is the <em>elimination</em> rule for the operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math>. You may think of <strong>VAR</strong> rules as both an introduction as well as an elimination rule (it introduces nothing and eliminates nothing). This style of presentation of logical rules is due to Gentzen and plays an important role in designing type theoretic systems. The introduction rules gives ways to “construct” objects of a given type and elimination rules gives ways to “use” the objects in expressions. All other operators that we introduce here will also have introduction and elimination rules.</p>
<h1 id="the-operators-and-.">The operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math>.</h1>
<p>We would like our logic to have the conjunctions and disjunctions. At the type level we just need to add two additional type formation operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>. As a result our types are now inductively defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex"> τ ≔ t ∈ 𝒯 | τ_1 → τ_2 | τ_1 ∧ τ_2 | τ_1 ∨ τ_2.</annotation></semantics></math></p>
<p>To prove conjunctions and disjunctions, we need ways to create values (remember they are our proofs) of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∧ τ_2</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> respectively. For conjunctions, we introduce the primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>.</mi><mo>,</mo><mi>.</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(.,.)</annotation></semantics></math> that pairs up two expressions to give a new expression. A value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> can be created in two ways: by applying the <em>constructor</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inl}</annotation></semantics></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> or by applying the constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inr}</annotation></semantics></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. These give the required introduction rules for the logical operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>:</p>
<p><strong>DISJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1}{Γ ⊢ \mathbf{inl}\; e \;: τ_1 ∨ τ_2},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_2}{Γ ⊢ \mathbf{inr} \;e \;: τ_1 ∨ τ_2}.</annotation></semantics></math></p>
<p><strong>CONJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e_1 : τ_1;\; Γ ⊢ e_2 : τ_2}
		{Γ ⊢ (e_1,e_2) : τ_1 ∧ τ_2}.</annotation></semantics></math></p>
<p>The justification of these rules from a proof theoretic point of view is that one can give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∧ τ_2</annotation></semantics></math> by giving a <em>pair</em> of proofs where the first component is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and the second a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. Similarly, we give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> by giving either a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> except that we need to explicitly state which is the case by using the appropriate constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inl}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inr}</annotation></semantics></math>.</p>
<p>Next we give the elimination rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math>. The corresponding language primitive that we need is the projection operators which we add as built in functions in our calculus.</p>
<p><strong>PROJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐬</mi><mi>𝐭</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>1</mn></msub></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1 ∧ τ_2}{Γ ⊢ \mathbf{fst}\; e \; :\; τ_1},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐧</mi><mi>𝐝</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
	\frac{Γ ⊢ e : τ_1 ∧ τ_2}{Γ ⊢ \mathbf{snd}\;e \;:\; τ_2}.</annotation></semantics></math></p>
<p>Similarly, to obtain the elimination rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>, we add the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐢</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{either}</annotation></semantics></math> that does case by case analysis.</p>
<p><strong>CASE</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>l</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><mi>τ</mi><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>r</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub><mo accent="false">→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐢</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐫</mi></mstyle><mspace width="0.278em"></mspace><mi>l</mi><mspace width="0.278em"></mspace><mi>r</mi><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1 ∨ τ_2;\;Γ ⊢ l : τ_1 → τ;\; Γ ⊢ r : τ_2 → τ}
		{Γ ⊢ \mathbf{either}\;l\;r\;e\;:τ}.</annotation></semantics></math></p>
<p>We define the the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo accent="false">↔</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">σ ↔ τ</annotation></semantics></math> of logical equivalence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo accent="false">→</mo><mi>τ</mi><mo stretchy="false" form="postfix">)</mo><mo>∧</mo><mo stretchy="false" form="prefix">(</mo><mi>τ</mi><mo accent="false">→</mo><mi>σ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(σ → τ) ∧ (τ → σ)</annotation></semantics></math>.</p>
<h1 id="truth-falsity-and-negation.">Truth, falsity and negation.</h1>
<p>We have a proof theoretic view of truth and falsity in this setting. Propositions are “true” if they can be proved by giving a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression of that type and not true otherwise. In that sense, we only have “truths” and “not truths” and every inhabited types, i.e. types for which we can construct an element with that type, is true. Explicit truth and falsity can be achieved by adding types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> to the basic types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and to make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math> provable, we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus with a single constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math>. That there is no constants with type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> is deliberate design choice as we do not want to prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> in our logic. Once we have the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math>, we can define the negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">¬ τ</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> to be the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>⊥</mi></mrow><annotation encoding="application/x-tex">τ → ⊥</annotation></semantics></math>.</p>
<p>The <em>law of excluded middle</em>, LEM for short, is the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">↔</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ ↔ ¬ ¬ τ</annotation></semantics></math> and is <em>not</em> a basic axiom of our logic. We can in fact prove one direction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → ¬ ¬ τ</annotation></semantics></math>: Consider the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>f</mi><mi>.</mi><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x f . f x</annotation></semantics></math>. It is easy to see that we can assign to it the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mi>τ</mi><mo accent="false">→</mo><mi>σ</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">τ → (τ → σ) → σ</annotation></semantics></math> for any types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In particular, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> is the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math>, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → ¬¬τ</annotation></semantics></math>. The converse however is not provable. This might be considered as a weakness of the logic because LEM is used through out mathematics. However, there is a distinct advantage here.</p>
<ol style="list-style-type: decimal">
<li><p>The proofs that we build are <em>constructive</em> and</p></li>
<li><p>If we are in dire need of the opium called LEM, we can recover it by adding a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">↔</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ ↔ ¬¬ τ</annotation></semantics></math> the way we added the constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math>. However, this is never done in practice when using a proof assistant like <code>coq</code> or <code>agda</code></p></li>
</ol>
<h1 id="comparison-to-untyped-λ-calculus.">Comparison to untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus.</h1>
<p>For any typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e : τ</annotation></semantics></math> we can get an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term, denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> itself, by ``erasing’’ out all types from abstractions. Is it possible to do the other way? Can we assign types to an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression in a way that is consistent to the rules defined above? Doing this algorithmically is the type inference problem. For example, consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x . x</annotation></semantics></math>. Intuition tells us that this can be assigned any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → τ</annotation></semantics></math> as it is the identity function. Indeed this is the case:</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">\{x : τ\} ⊢ x : τ</annotation></semantics></math> by <strong>VAR</strong></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">⊢ (λ x : τ . x) : τ → τ</annotation></semantics></math> by <strong>ABS</strong> and (1).</p></li>
</ol>
<p>It turns out that not all terms can be consistently typed, for example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x . xx</annotation></semantics></math> cannot be assigned any type (why?).</p>
<p>Recall that the computational content of untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus is captured in the notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction. To avoid variable collision we also need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversions. It is easy to see that notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction can be defined in a straight forward way for typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus. What then is the difference? The typed version of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction is <em>strongly normalising</em>. It turns out that term like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Ω= (λx . xx) (λx .xx)</annotation></semantics></math> and fixed point combinators cannot be consistently typed. As a result general recursion, and hence infinite loops, are <em>not</em> possible in this calculus.</p>
<h1 id="consistency-and-recursion">Consistency and recursion</h1>
<p>The Curry-Howard isomorphism gives us a way to define logical system out of typed lambda calculus. Enriching the basic typed lambda calculus with constants like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math> is like adding axioms to the logical system assoicated with the language. In any logical system, we need to worry about consistency. In classical logic, a set of axioms together with the inference rules form an <em>inconsistent</em> system if one can prove a statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> and its negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">¬τ</annotation></semantics></math>. This definition is not very useful in the type theoretic setting as it is crucially dependent on negation which we want to avoid as much as possible. An alternate way to define inconsistency is to define inconsistent system as those which proves all statements. It is this definition of inconsistency that is easier to work with in the type theoretic framework. We say that a type theoretic system, i.e. the under lying typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus and its type inference rules, is <em>inconsistent</em> if <em>every</em> type in <em>inhabited</em>. This makes sense because an inhabitant of a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> is the proof of the statement (associated) to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In this section, we want to connect consistency and the ability to do recursion. In fact, arbitrary recursion, or equivalently a uniform way to compute fixed points, is dangerous from a consistency perspective.</p>
<p>We saw that the typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus that we defined does not support fixed point combinators and therefore does not support recursion. This severely limits the kind of programs that one can write in such a language. However, we <em>do</em> know that fixed points can be implemented on a computer. Can we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus to include a fixed point combinator by force? After all, we do know how to compile it into machine code. What would happen if we just enrich the calculus with a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><annotation encoding="application/x-tex">\mathbf{fix}</annotation></semantics></math>, much like the way we included a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math>. For this to workout, we would need to augment our type inference rules with the following rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><annotation encoding="application/x-tex">\mathbf{fix}</annotation></semantics></math></p>
<p><strong>FIX</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>f</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ f : τ → τ}
		{Γ ⊢ \mathbf{fix}\;f\;:\; τ}.</annotation></semantics></math></p>
<p>This would mean that, if we some how create a function of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">f:τ→τ</annotation></semantics></math> then we can prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> using the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathbf{fix}\; f</annotation></semantics></math>. Recall that, for any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>, the typed lambda calculus expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">I = λ x : τ . x</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → τ</annotation></semantics></math>. Taking its fixed point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>I</mi></mrow><annotation encoding="application/x-tex">\mathbf{fix}\; I</annotation></semantics></math> will give an inhabitant of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Therefore, adding arbitrary fixed points will make the logic inconsistent.</p>
<p>Real world programming languages like Haskell does not care about this issue as writing infinite loops are too important for a programmer. In fact, every type in Haskell has an inhabitant, namely <code>undefined</code>. What this means is that the type system of Haskell is not directly suitable as a theorem prover although we can still use it to catch many bugs at compile time.</p>
<p>Languages like agda which has to double up as a proof assistant allow certain restricted kinds of recursion by making sure that the recursion is well formed. Other than the motivation to write real world programs, some restricted form of recursion is actually necessary to capture mathematical objects like natural numbers etc. We leave these issues for future posts.</p>
</div>

<div class="post-comments">
  <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2014-01-11-Typed-lambda-calculus.html';
                          // The url of this page
  var disqus_title      = 'Typed lambda calculus';      // The title of this post
  var disqus_identifier = '2014-01-11-Typed-lambda-calculus';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="fa fa-flag"></i> Fontawesome</a>
</div>

  </body>
</html>
