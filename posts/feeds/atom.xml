<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Delusions of a chaotic mind</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/feeds/atom.xml" rel="self" />
    <link href="http://cse.iitk.ac.in/users/ppk" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/feeds/atom.xml</id>
    <author>
        <name>Piyush P Kurur</name>
        <email>ppk@cse.iitk.ac.in.REMOVETHISIFYOUAREAHUMAN</email>
    </author>
    <updated>2017-04-04T00:00:00Z</updated>
    <entry>
    <title>Beware of numeric type classes.</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2017-04-04-Beware-of-Numeric-Types.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2017-04-04-Beware-of-Numeric-Types.html</id>
    <published>2017-04-04T00:00:00Z</published>
    <updated>2017-04-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This blog post is to document some cases where unconstrained Num type definitons can seriously compromise type safety. None of what I say here is new but it is worth repeating. Take it as a note of warning against being zealous when defining instances of some standard type classes, in particular the <code>Num</code> class</p>
<p>Here is an example from the cryptographic library <code>Raaz</code>. To prevent inadvertent use of the wrong offset measure, raaz uses what we call type-safe lengths. One such length is <code>BYTES</code> but there are others. For example, the type <code>BLOCKS c</code> measures length in multiples of the block length of the the cipher <code>c</code>. The advantage of such a definition is that for low level functions like <code>encryptBlocks</code> the length argument is in <code>BLOCKS c</code> which ensures that one does not accidently supply length in bytes. The constructors of BLOCKS should not be directy availabe to the outside world to avoid users from circumventing such gurantees. Instead we define a class <code>LengthUnit</code> which has a member function that converts instances to <code>BYTES</code>. This instance function is what is use to perform the actual size calculation of pointer manipulation.</p>
<p>It is tempting to define the <code>Num</code> instance for <code>BLOCKS</code> as this is a great convenience for users. However, such an instance will effectively bypass all the type safety we so carefully built into the system. Consider for example, a code like <code>encryptBlocks chacha20imp ptr 42</code>. Haskell is able to infer that the 42 is of type <code>BLOCKS ChaCha20</code> because it knows the type of <code>chacha20imp</code>. This will not raise any kind of type error and will result in encrypting 42 blocks (i.e. 2688 bytes) of data. This is a disaster if the user actually meant only <code>42</code> bytes. Haskell should not have the privilege of such bugs unlike others like Fortran (See <a href="http://en.wikipedia.org/wiki/Mariner_1" title="Wikipedia: Mariner 1">Mariner 1</a>).</p>
<p>A theoretical reason to see why the <code>Num</code> instance is plain wrong for length units is the see that multiplication does not make sense here. In the language of physics, length offset is <em>not</em> a dimensionless scalar and hence the product of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>6</mn><mstyle mathvariant="normal"><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mstyle><mo>×</mo><mn>7</mn><mstyle mathvariant="normal"><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mstyle></mrow><annotation encoding="application/x-tex">6\mathrm{bytes} × 7 \mathrm{bytes}</annotation></semantics></math> is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>42</mn><msup><mstyle mathvariant="normal"><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mstyle><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">42 \mathrm{bytes}^2</annotation></semantics></math> which is not a length unit at all. On the other hand, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mo>*</mo><mn>4</mn><mstyle mathvariant="normal"><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi></mstyle></mrow><annotation encoding="application/x-tex">10 * 4 \mathrm{ bytes}</annotation></semantics></math> makes sense when calculating the size of say an array of <code>Word32</code> of length 10. This is because the quantity 10 is a <em>dimensionless</em> and therefore the resulting product has the same dimension as bytes.</p>
<p>In the heat of the moment it is pretty easy to overlook these bugs. This is particularly tempting because of the “unnecessary” boilerplate that it gets rid of that to, at a very minimal cost; just a <code>deriving</code> clause away. I would freely confess my stupidity in this aspect. At least we have <a href="https://github.com/raaz-crypto/raaz/issues/247">repented</a> and <a href="https://github.com/raaz-crypto/raaz/pull/251">corrected</a> this to avoid perdition. [compilers]: <a href="https://bitbucket.org/piyush-kurur/compilers" class="uri">https://bitbucket.org/piyush-kurur/compilers</a> “Compilers” [ppt]: </teaching> “Programs, Proofs and Types”</p>]]></summary>
</entry>
<entry>
    <title>Adventures in optimising ChaCha20 for Raaz.</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2017-02-06-Adventures-in-optimising-chacha20.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2017-02-06-Adventures-in-optimising-chacha20.html</id>
    <published>2017-02-06T00:00:00Z</published>
    <updated>2017-02-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post, I note down some of the things I learned while optimising ChaCha20 implementation in the Raaz library.</p>
<p><strong>TLDR:</strong> Do not waste time on hand optimising when there is GCC, the beast from the savanna.</p>
<h2 id="a-brief-description-of-the-chacha20">A brief description of the ChaCha20</h2>
<p>We have a chacha state which is essentially a 4x4 matrix of 32-bit unsigned word (<code>Word32</code> in Haskell). The main body of the chacha transform consists of performing a quarter round, QROUND from now on, first on all the rows of the matrix and then on each of the diagonals of the matrix. For example, if the matrix is</p>
<pre><code>	x0  x4  x8   x12
	x1  x5  x9   x13
	x2  x6  x10  x14
	x3  x7  x11  x15
</code></pre>
<p>Then a single round of ChaCha20 is the following operations.</p>
<pre><code>
	QROUND(x0, x4, x8,  x12); // QROUND(row0)
	QROUND(x1, x5, x9,  x13); // QROUND(row1)
	QROUND(x2, x6, x10, x14); // QROUND(row2)
	QROUND(x3, x7, x11, x15); // QROUND(row3)


	QROUND(x0, x5, x10, x15); // QROUND(diag0)
	QROUND(x1, x6, x11, x12); // QROUND(diag1)
	QROUND(x2, x7, x8,  x13); // QROUND(diag2)
	QROUND(x3, x4, x9,  x14); // QROUND(diag3)
</code></pre>
<p>The chacha20 stream is generated by performing this row and diagonal transformations 20 times followed by some adding up.</p>
<p>The first step was to get a portable version of ChaCha20 with the associated tests, which was done without much difficulty. You can have a look at it <a href="https://github.com/raaz-crypto/raaz/blob/master/cbits/raaz/cipher/chacha20/cportable.c" class="uri">https://github.com/raaz-crypto/raaz/blob/master/cbits/raaz/cipher/chacha20/cportable.c</a> There was nothing clever here other than making sure that the variables xi’s are declared register.</p>
<h2 id="vector-optimisations">Vector optimisations</h2>
<p>The quarter round essentially consists of only addition and xor. It can easily be seen that the 4-row operations are independent of each other. Similarly the four diagonal operations are independent of each other. If we store each of the rows in a 128-bit vector consisting of 4 <code>Word32</code>’s, then the 4-row QROUND can be performed by a single vector version of QROUND. In other words, if we have the vectors</p>
<pre><code>V0 = {x0,   x1,   x2,   x3 };
V1 = {x4,   x5,   x6,   x7 };
V2 = {x8,   x9,   x10,  x11};
V3 = {x12,  x13,  x14,  x15};


</code></pre>
<p>then the <em>single</em> <code>QROUND(V0,V1,V2,V3)</code> performs the <code>QROUND</code> for all the rows. For the diagonal ones we need to shift <code>V1</code>,<code>V2</code>, and <code>V3</code> by 1, 2, and 3 positions to the left respectively and perform a <em>single</em> <code>QROUND(V0,V1,V2,V3)</code> again.</p>
<p>The optimisation for 256-bit vector instructions is similar, but we have to do 2-chacha blocks at a time. This is possible because the two chacha20 blocks differ only by a counter and can be done in parallel.</p>
<p>With the above optimisations I wrote two versions, one using the 128-bit vector the other using 256-bit version using the support for vector types in GCC. Again the implementation was delightfully simple, in fact in many ways much simpler than the portable one because now we can use vector types. The result of these optimisations were not very impressive though.</p>
<ol style="list-style-type: decimal">
<li><p>The performance of 128-bit vector version as compared to the portable version does not improve at all (actually it is slightly worse) instead of the expected 2x improvement.</p></li>
<li><p>The performance of 256-bit version with avx2 is better than the portable one by roughly a factor of 2x where as the naive expectations are a 4x improvement<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>.</p></li>
</ol>
<p>I did look at the generate assembly and the code looked much like what was expected. The 128-bit code was using <code>%xmm</code> registers as expected and the 256-bit version was using the <code>%ymm</code> registers.</p>
<h2 id="letting-the-beast-loose.">Letting the beast loose.</h2>
<p>Cabal install and stack compiles C code with <code>-O2</code>. Just to see what has GCC got under its hood, I compiled stuff with the flags <code>-O3</code> and what a surprise/shock I had. The portable C started competing with the 256-bit implementation. The generated assembly had the SIMD registers in it. Encouraged, I decided to throw in the <code>-march=native</code> and the figures blew me off. The portable C implementation was giving me an insane 14.4 Gbps where as the 256-bit one was only giving me 9.55Gbps.</p>
<h2 id="final-tweaking-and-cabal-flags.">Final tweaking and Cabal flags.</h2>
<p>I can make two assumptions on the the message blocks because they are used only through FFI. Firstly, I can assume that the message block is 32-byte (256-bit) aligned by making sure that the Haskell stub function only passes 32-byte aligned buffers to the portable C implementation. Implementations of primitives in Raaz are instances of the <code>BlockAlgorithm</code> class. All I need to do is to ensure is that <code>bufferStartAlignment</code> is 32 for portable C implementation as opposed to word alignment. I can also assume that the pointer is not aliased. This two tweaks gives only minor improvements and need not be included at all.</p>
<p>The final performance figures are available at:</p>
<p><a href="https://gist.github.com/piyush-kurur/93955e669ab72a51996590bfc106677d" class="uri">https://gist.github.com/piyush-kurur/93955e669ab72a51996590bfc106677d</a></p>
<p>The cabal package now has two flags <code>opt-native</code> and <code>opt-vectorise</code> which results in adding the flags <code>-O2 -ftree-vectorize -march=native</code>. These are not enabled by default but can be enabled if you are compiling for yourself. With these changes there is no more a need for the vector implementations. I am keeping it for historical records.</p>
<h2 id="who-should-not-enable-the-above-flags">Who should not enable the above flags?</h2>
<p>If you are cross compiling, for example, when you are compiling the code for packaging for a distro, it is not advisable to enable these flags. Note that the native in this case would mean the machine on which it is compiled and not on the one where it is run. There is not much of an advantage in the hand coded vector implementation either because one cannot make assumptions on the target.</p>
<p>If you know that your target machine supports vector instructions, you can vectorise with <code>-O2 -ftree-vectorize</code>. Throw in an <code>-mavx2</code>, if you are sure of its supported on the target, and get most of the performance described above. This would be the use case when you are compiling on your local machine but deploying on the cloud for example.</p>
<p><strong>Update:</strong> I got rid of the <code>restrict</code> key word in the portable c file because not all GCC versions seem to be familiar with it.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The naive expectation will not hold because of some vector overheads. [compilers]: <a href="https://bitbucket.org/piyush-kurur/compilers" class="uri">https://bitbucket.org/piyush-kurur/compilers</a> “Compilers” [ppt]: </teaching> “Programs, Proofs and Types”<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Raaz: New release</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2017-02-02-Raaz-new-release.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2017-02-02-Raaz-new-release.html</id>
    <published>2017-02-02T00:00:00Z</published>
    <updated>2017-02-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I have just uploaded, on hackage, a <a href="https://hackage.haskell.org/package/raaz-0.1.0/candidate">new release candidate</a> for <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a>. I plan to release it on Feb 28, 2017 (coinciding with the <a href="http://en.wikipedia.org/wiki/National_Science_Day" title="Wikipedia: National Science Day">National Science Day</a> in India).</p>
<ul>
<li><a href="https://github.com/raaz-crypto/raaz/blob/release-0.1.0/CHANGELOG.md" title="Change log for 0.1.0">Change log</a></li>
<li><a href="https://hackage.haskell.org/package/raaz-0.1.0/candidate">Candidate release page</a> on hackage.</li>
</ul>
<p>This release include the following primitives</p>
<ul>
<li><p><a href="https://tools.ietf.org/html/rfc7539" title="ChaCha20 RFC">chacha20</a> stream cipher</p></li>
<li><p>a prg based on <a href="https://tools.ietf.org/html/rfc7539" title="ChaCha20 RFC">chacha20</a></p></li>
</ul>
<p>Besides the portable C implementation, we have an implementation that uses 256bit vector instructions (using GCC/Clang intrinsics). The randomness source for this library uses the chachac20 cipher as a PRG. The stream cipher is really efficient with the following figures on my machine<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a></p>
<ul>
<li>Encryption/decryption:
<ul>
<li>portable C: 4.98 Gbps</li>
<li>vector256+avx2: 9.55 Gbps</li>
</ul></li>
<li>Pseudo-random bytes: 5.45 Gbps</li>
</ul>
<p>Notice that the vector256+avx implementation can pretty much saturate a 10Gbps line. The PRG uses the most efficient <a href="https://tools.ietf.org/html/rfc7539" title="ChaCha20 RFC">chacha20</a> implementation available, which in this case is vector256+avx2. The reduction in performance for prg is due to some copying overhead that I have not bothered to optimise. For more details and comparisons with other primitives see the gist:</p>
<p><a href="https://gist.github.com/piyush-kurur/93955e669ab72a51996590bfc106677d" class="uri">https://gist.github.com/piyush-kurur/93955e669ab72a51996590bfc106677d</a></p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Intel i7-4770 CPU @ 3.40GHz x 8 cores. [compilers]: <a href="https://bitbucket.org/piyush-kurur/compilers" class="uri">https://bitbucket.org/piyush-kurur/compilers</a> “Compilers” [ppt]: </teaching> “Programs, Proofs and Types”<a href="#fnref1">↩</a></p></li>
</ol>
</div>]]></summary>
</entry>
<entry>
    <title>Haskell 2016: impressions of a first timer</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2016-09-27-Haskell-2016-impressions-of-a-first-timer.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2016-09-27-Haskell-2016-impressions-of-a-first-timer.html</id>
    <published>2016-09-27T00:00:00Z</published>
    <updated>2016-09-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>I had an exhausting yet exciting trip to Nara where for the first time I interacted with the functional programming community. What started out as a hobby is taking its toll on me; I am getting sucked in deeper and deeper into functional programming and it seems I am not minding that.</p>
<p>The broad area of functional programming and type theory is seeing a revolution of some sort. For a functional programmer it seems nothing is “esoteric” as long as it helps in solving the nut and bolt problems encountered in designing reliable software. It would not surprise me if the next big idea after sliced bread and monads rise from the murky depths of <a href="http://www.homotopytypetheory.org/" title="Homotopy type theory">hott</a> and become suddenly mainstream. A large contingent of participants were from the Industry, not the usual suspects like Microsoft Research, but from startups, banks, trading companies (Wolves of wallstreet?). That is extremely satisfying to a researcher in this area.</p>
<p>For me, this conference is also special in the sense that for the first time, I collaborated with some one (<a href="http://ozark.hendrix.edu/~yorgey/" title="Brent Yorgey">Brent Yorgey</a>) whom I have never met face to face before. I am amazed at the intensity with which we worked with git as the medium of communication. This was more like the collaboration in the free software world than the typical academics collaboration that I am more used to. I wish academics moves more to this kind of a model.</p>
<p>This is also my second visit to Japan and I should say I am just as impressed now as I was in 2003. For a fan of fast trains like me, Japan is the ultimate destination of course. But Japan is not just tech. Its culture, food and the subtle aesthetics are all impressive. No wonder this land produced geniuses like <a href="http://en.wikipedia.org/wiki/Akira_Kurosawa" title="Wikipedia: Akira Kurosawa">Akira Kurosawa</a> or <a href="http://en.wikipedia.org/wiki/Hayao_Miyazaki" title="Wikipedia: Hayao Miyazaki">Hayao Miyazaki</a>.</p>]]></summary>
</entry>
<entry>
    <title>Handling secure memory in Raaz.</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2016-08-02-Handling-Secure-Memory-in-Raaz.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2016-08-02-Handling-Secure-Memory-in-Raaz.html</id>
    <published>2016-08-02T00:00:00Z</published>
    <updated>2016-08-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h1 id="the-problem">The problem</h1>
<p>Cryptographic software need to keep confidential data like private keys in its memory. Unless the machine is severly compromised, this is safe as no other process can access them and the data vaporises once the power is turned off. However, if the operating system swaps the data into external memory (hard disk) during the execution of the program, the secret data gets stored on permanent memory and can remain live for years to come. Therefore it is clear that one needs to prevent the OS from swapping out data that is sensitive and typical operating systems provide system calls <code>mlock/munlock</code> which locks/unlocks memory from being swapped. The library should lock all the memory that contains sensitive data and after use should wipe the memory clean before unlocking and freeing.</p>
<h2 id="a-solution-using-foreignptr.">A “solution” using <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr" title="Foreign Pointer"><code>ForeignPtr</code></a>.</h2>
<p>The <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr" title="Foreign Pointer"><code>ForeignPtr</code></a> type in Haskell is a pointer together with a finalisation routine. When the pointer goes out of scope, the finalisation routine is run before the memory is de-allocated. A naive solution for storing sensitive data is to store it in a <em>locked</em> <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr" title="Foreign Pointer"><code>ForeignPtr</code></a> based buffer. The finalisation step of this foreign pointer should wipe the memory clean and unlock it. This seamingly easy solution has the following problem.</p>
<p>The system calls <code>mlock</code>/<code>munlock</code> works at the level of pages, i.e. it locks or unlocks multiple of pages. Now consider two locked buffers <code>b₁</code> and <code>b₂</code> where <code>b₁</code> ends at the first byte of a page and <code>b₂</code> is the rest of the page. Then unlocking <code>b₁</code> will also unlock <code>b₂</code> as <code>munlock</code> unlocks all the pages that contains part of <code>b₁</code>. If <code>b₁</code> and <code>b₂</code> are foriegn pointers, then when the gc notices that <code>b₁</code> gets out of scope it will unlock <code>b₁</code> as well as <code>b₂</code> (because the entire page is unlocked). In other words nesting of mlock and munlock does not work. This clearly is not acceptable.</p>
<p>Of course this idea can be made to work by building a mini-garbage collecter inside the crypto-library. We should maintain a pool of <em>locked</em> memory pages and <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr" title="Foreign Pointer"><code>ForeignPtr</code></a>’s meant to be used for sensitive data should be allocated from this pool. The finaliser of the these <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Foreign-ForeignPtr.html#t:ForeignPtr" title="Foreign Pointer"><code>ForeignPtr</code></a>’s do not unlock immediately on going out of scope but merely mark that a given chunk of memory is unused. A particular page can be unlocked only when no portion of it is part of any live secure foreign pointers. With some book-keeping such an allocator can be built but it is tricky. We need to take care of all the issues related to garbage collection like fragmentation besides knowing system level details like page sizes. An ancient version of raaz had such a memory allocator and it was not pretty.</p>
<h2 id="raazs-simplified-memory-model.">Raaz’s simplified memory model.</h2>
<p>The main idea behind the secure memory interface is that we allocate all the required secure memory in one go. This approach is faster and simpler. We describe this interface here.</p>
<p>In Raaz we have the notion of an abstract memory element which are buffers wrapped in an appropriate type. These are instances of the class <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Memory.html#t:Memory" title="The Memory type class"><code>Memory</code></a>.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">class</span>  <span class="dt">Memory</span> mem <span class="kw">where</span>
<span class="ot">&gt;   memoryAlloc    ::</span>  <span class="dt">Alloc</span> mem       <span class="co">--  allocation strategy</span>
<span class="ot">&gt;   underlyingPtr  ::</span>  mem <span class="ot">-&gt;</span> <span class="dt">Pointer</span>  <span class="co">--  recover the pointer</span></code></pre></div>
<p>The type <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#t:Alloc" title="Allocation strategy"><code>Alloc mem</code></a> captures what we call an <em>allocation strategy</em> for the memory element <code>mem</code>. This is essentially a pair <code>(Pointer -&gt; mem, Int)</code> which encodes the following:</p>
<ol style="list-style-type: decimal">
<li><p>The <code>Int</code> portion keeps track of the amount of memory that is required to create the memory element <code>mem</code>.</p></li>
<li><p>The <code>Pointer -&gt; mem</code> part gives the constructor for the memory element, i.e. it gives a function that takes a pointer which points to a block of memory, and create the memory element.</p></li>
</ol>
<p>All actions that require secure memory should be of the type <code>mem -&gt; IO a</code> for some memory element <code>mem</code>. In the library, this is captured by the type <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#t:MT" title="Memory action"><code>MT mem a</code></a>. It is easy to see that one can easily define a higher order function <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#v:securely" title="running the memory action securely"><code>securely :: MT mem a -&gt; IO a</code></a> that takes such a memory action and passes it a memory element by constructing it out of a locked memory of appropriate size. At the end of the action, this combinator also ensures that the memory is wiped clean before unlocking the memory. Such a use which involves a single mlock/munlock call is not problematice. Besides we do not need to know any system dependent parameters.</p>
<p>What about more complicated actions action that requires many such memory elements, say for example <code>mem1</code> and <code>mem2</code>? We think of it as an action that takes the pair <code>(mem1, mem2)</code>. This requires us to define a memory instance for product types which becomes too tedious because of the pointer arithmetic and size calculation involved in defining its allocation strategy. Every such low level code has the word disaster written all around it.</p>
<p>It turns out that an <a href="https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a> functor instance can be defined on the type <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#t:Alloc" title="Allocation strategy"><code>Alloc</code></a> <em>which does the right thing</em>. The allocation strategy for the compound type (a product of simpler memory types) can be constructed out of the allocation strategy of its components using this applicative interface. The <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Memory.html#t:Memory" title="The Memory type class"><code>Memory</code></a> instance of a product type will then be something along this lines:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">instance</span> (<span class="dt">Memory</span> mem1, <span class="dt">Memory</span> mem2) <span class="ot">=&gt;</span> <span class="dt">Memory</span> (mem1, mem2) <span class="kw">where</span>
<span class="ot">&gt;</span>     memoryAlloc         <span class="fu">=</span> (,) <span class="fu">&lt;$&gt;</span> memoryAlloc <span class="fu">&lt;*&gt;</span> memoryAlloc
<span class="ot">&gt;</span>     underlyingPtr (m,_) <span class="fu">=</span> underlyingPtr m</code></pre></div>
<p>Note that all the book keeping involved in the length calculations and pointer arithmetic is hidden in the applicative interface. All Implementations of primitives in Raaz always use a memory element to keep its internal state secure.</p>
<p>To bootstrap the process, the library provides some basic memory types like <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Memory.html#t:MemoryCell" title="The Memory type class"><code>MemoryCell</code></a>. Compound memory types (which are essentially product of simpler memory types) can be built out of them using this <a href="https://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative"><code>Applicative</code></a> instance of <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#t:Alloc" title="Allocation strategy"><code>Alloc</code></a>.</p>
<h2 id="does-it-still-keep-things-from-swapping-out">Does it still keep things from swapping out?</h2>
<p>Unfortunately, there can still be instances where things can go outside secure memory. For example, if you reads the contents of a memory cell into a pure value of Haskell, the contents have leaked into the Haskell Heap which might be swapped. However, with care we can minimise such explicit reads. Copying from one memory cell to another can be done using a memcpy which does not involve such transfer to the heap.</p>
<p>For the actual implementation see the documentation of the module <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html" title="Raaz: Secure memory">Raaz.Core.Memory</a>. The theory behind the applicative structure of <a href="https://hackage.haskell.org/package/raaz-0.0.2/docs/Raaz-Core-Memory.html#t:Alloc" title="Allocation strategy"><code>Alloc</code></a> is dealt with in <a href="../research/publication/Conference/2016-09-22-How-to-twist-pointers.pdf" title="How to twist pointer without breaking them">our upcoming paper in Haskell 2016</a>.</p>]]></summary>
</entry>
<entry>
    <title>Why another cryptolibrary?</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2016-07-30-Why-another-cryptolibrary.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2016-07-30-Why-another-cryptolibrary.html</id>
    <published>2016-07-30T00:00:00Z</published>
    <updated>2016-07-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Haskell is already endowed with a comprehensive set of libraries for cryptography like <a href="https://hackage.haskell.org/package/cryptonite" title="Cryptonite: Cryptography Primitives sink">cryptonite</a>, for example. What justifies working on another cryptographic library, after all isn’t the 11-th commandment “Thou shall not (re)-implement cryptography” ? This post is <em>not</em> a <a href="https://hackage.haskell.org/package/cryptonite" title="Cryptonite: Cryptography Primitives sink">cryptonite</a> vs <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> comparison — a simple look at the haddock documentations of the two libraries should convince anyone that <a href="https://hackage.haskell.org/package/cryptonite" title="Cryptonite: Cryptography Primitives sink">cryptonite</a> is far ahead of <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a>. This post is an attempt at bringing out the reasons for working on <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> and what is the rough road map that I intend to follow. But firstly I would like to dispose of two myths that seems to be prevalent on the internet at large when it comes to cryptographic library.</p>
<p>Firstly, I would like to dispose of the unnecessary fear of (re)-implementing cryptography. This fear is unfounded and, I believe, is partly responsible for open source libraries like OpenSSL becoming the “enterprise” level crypto-implementation that it is now. How else does one explain a successful open source project becoming such a nightmare of a code base? Cryptographic libraries are software libraries in the first place so all the best practices for building large scale software should be applicable to it as well. How can it be otherwise? I am not denying the fact that there are certain class of bugs unique to cryptographic implementations like timing based attacks. However, once these class of bugs are identified, it is just a question of suitably modifying the development process to account for such bugs as well. As a Haskell programmer, one should be wondering how to exploit the type system to avoid these kinds of bugs.</p>
<p>The second myth is that one needs to be a professional cryptographer to write a cryptographic library. Granted, it is difficult if one is <a href="https://en.wikipedia.org/wiki/Donald_Trump" title="Donald Trum">Donald Trump</a> but one does not need to be <a href="http://cr.yp.to/djb.html" title="Daniel J Bernstein">djb</a> either to pull it off, although being the later does give some significant advantages. Building software in any field requires absorbing the nuances of the field and cryptography is no different. To drive home the point, it would be absurd to say that one should not work on an api to access databases just because one is not a database expert.</p>
<p>A professional cryptographer has an advantage but remember, she might not have experience building large software and might not be familiar with some of the cool tricks one can play with types. So if you think you are capable of developing complex software, with enough background reading and awareness of the literature, you should be able to contribute significantly in the development of a crypto-library.</p>
<p>I am <em>not</em> a professional cryptographer by any means. One of my current interest is to build reliable software by using formal methods whenever possible. With a strongly typed language like Haskell, I believe, one can go quite a bit in building a secure cryptographic library. This is my main motivation behind <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a>. The kind of bugs that we want to deal with are</p>
<ol style="list-style-type: decimal">
<li><p>Timing related bugs.</p></li>
<li><p>Bugs due to secret leaking out of unlocked memory.</p></li>
<li><p>Bugs arising due to low level buffer management.</p></li>
</ol>
<p><a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a> addresses all these in its own unique ways.</p>
<h2 id="timing-attacks.">Timing attacks.</h2>
<p>While timing related bugs are hard in general, for example cache-timing attacks for AES SBOX (current version of raaz uses an sbox), some trivial kind of timing attacks like the ones due to naive string comparisons should be avoided whenever possible. In a language like C, one does not have much hope here. Even if the library writer is careful enough to provide a timing independent string comparison, the enforcement of this is left at the whims and fancies of the application developer.</p>
<p><a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a> provides the class <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Types.html#t:Equality" title="Timing safe equality"><code>Equality</code></a>, the timing independent cousin of the <code>Eq</code> class. Instead of the the function <code>(==) :: Eq a =&gt; a -&gt; a -&gt; Bool</code> what we have is the function <code>eq : Equality a =&gt; a -&gt; a -&gt; Result</code>. Here the <code>Result</code> type is an opaque type that captures the result of a comparison. Two such comparisons can be combined using the monoid instance of <code>Result</code> which essentially takes the AND of the two results but does it in a timing safe way.</p>
<p>In <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> we insist that cryptographically sensitive types like hashes and MACs should have their <code>Equality</code> instance declared first. Their <code>Eq</code> instance is then declared using the combinator <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Types.html#v:-61--61--61-" title="The (===) operator"><code>(===)</code></a> which makes use of <code>eq</code> to do the timing safe comparison. Clearly, we cannot enforce this at compile time but we can look for this pattern while reviewing the code base. Anything other than this, like for example a <code>deriving Eq</code> clause, should raise suspicion.</p>
<h2 id="pointer-manipulation.">Pointer manipulation.</h2>
<p>The library needs a lot of low-level pointer manipulation in serialisation/de-serialisation and memory allocation. We have an abstraction for such pointer manipulation as a result of which, pointer arithmetic is done only once in the entire code base. The abstraction is based on a generalisation of semi-direct product and is described in our upcoming <a href="research/publication/Conference/2016-09-22-How-to-twist-pointers.pdf" title="How to twist pointer without breaking them">Haskell symposium paper</a>. In particular, our secure memory interface uses this abstraction.</p>
<h2 id="known-limitations-and-future-directions.">Known limitations and future directions.</h2>
<p>My first aim is to get the API correct. We have place holder implementations of the SHA2 family of hashes and aes-cbc but we have not really tweaked these either for security or performance. The AES code for example uses sbox which is <a href="http://cr.yp.to/antiforgery/cachetiming-20050414.pdf">not really a great idea</a>.</p>
<p>In no particular order these are the current goals (comments, criticism and most importantly pull requests are welcome).</p>
<ol style="list-style-type: decimal">
<li><p>High quality documentation (both haddock and internal source code level documentation).</p></li>
<li><p>Using types every where. The types should work for us even at the lowest of the levels at which we work.</p></li>
<li><p>Formalising a reviewer’s check list which contains things to actively look for while reviewing code. The example of the <code>Equality</code> instance is one such.</p></li>
<li><p>Building against multiple architecture. This is to detect bugs due to alignment restrictions, endianness confusion etc. One easy way to get this working is to build on Ubuntu launch pad.</p></li>
</ol>
<p>It does not mean I will be unhappy with merging a <a href="http://crypto.stackexchange.com/questions/55/known-methods-for-constant-time-table-free-aes-implementation-using-standard">bit-sliced implementation of AES-CTR</a> but the above ones are my priorities as of now.</p>]]></summary>
</entry>
<entry>
    <title>First release of Raaz</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2016-07-11-First-release-of-Raaz.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2016-07-11-First-release-of-Raaz.html</id>
    <published>2016-07-11T00:00:00Z</published>
    <updated>2016-07-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>After a long delay, and a lot of false detours, I released the very first version of <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a>, a cryptographic network library for <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a>. My reasons on embarking on such a project is briefly mentioned in a <a href="../posts/2013-08-24-Raaz-A-cryptographic-network-library.html">previous post</a>.</p>
<p>The current release is mostly a proof of concept release with very little primitives; we currently support sha1, sha2 hashes and their hmacs. We also have an implementation of aes-cbs but these are hard to use in an high level fashion.</p>
<h1 id="quick-examples.">Quick examples.</h1>
<p>We demonstrate the interface for computing message digests based of cryptographic hashes. Raaz uses distinct types for distinct hashes. These types are opaque in the sense that we do not expose its constructor. However, they are instances of the <code>IsString</code> and <code>Show</code> class which makes them conviently representable in code.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.ByteString.Char8</span>(<span class="dt">ByteString</span>)</code></pre></div>
<p>We now demonstrate how the sha512 digest of a file can be computed. All cryptographic hashes are instance of the type class <code>Hash</code> and the generic function <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Hash.html#t:hashFile" title="The hashFile function"><code>hashFile :: Hash h =&gt; FilePath -&gt; h</code></a> can be used to compute the hash of a file. The top level signature is necessary in this case so that ghc can deduce which hash to compute.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; fileDst ::</span> <span class="dt">IO</span> <span class="dt">SHA512</span>
<span class="ot">&gt;</span> fileDst <span class="fu">=</span> hashFile <span class="st">&quot;myphoto.jpg&quot;</span></code></pre></div>
<h2 id="entering-hashes-directly-in-source-code.">Entering hashes directly in source code.</h2>
<p>With the <code>OverloadedStrings</code> extension, you can enter the hashes directly in the source code using the string notation. However, for objects that do not have 1:1 correspondence with byte strings, use of this extension often lead to runtime errors and its use is generally <em>not recommended</em>. There are some rarely cases when it is convenient to embedd hash values in source code like when writing unit tests.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; emptySHA256 ::</span> <span class="dt">SHA256</span>
<span class="ot">&gt;</span> emptySHA256 <span class="fu">=</span> <span class="st">&quot;e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855&quot;</span></code></pre></div>
<p>Hashes can be compared for equality. What more, these comparison are constant time and hence timing safe.</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; check ::</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> check <span class="fu">=</span> emptySHA256 <span class="fu">==</span> hash (<span class="st">&quot;&quot;</span><span class="ot"> ::</span> <span class="dt">ByteString</span>)</code></pre></div>
<p>Notice that for pure values like ByteString, we use function <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Hash.html#t:hash" title="The hash function"><code>hash</code></a> to compute its digest. The result is also a pure value.</p>
<p>For more details, we refer the reader to the <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Hash.html" title="Documentation for Hashes in Raaz">haddock documentation of <code>Raaz.Hash</code></a></p>
<h2 id="design-philosopy.">Design philosopy.</h2>
<p>The raaz package will expose cryptographic primitives which will be used to implement specific cryptographic protocols (in separate packages). We would like to expose a high-level view of cryptographic primitives and levarage the type safety of Haskell when ever possible. Here are some design principles that we have followed which we believe are important.</p>
<dl>
<dt><strong>Types distinguish functionality:</strong></dt>
<dd><p>In cryptographic literature, data like hashes are often treated just as a sequece of bytes. For example, a string of 32 bytes, a sha256 hash or its hmac or for that matter any other hash like blake2s are all just 32-byte strings. For a crypto library this is a bad design. This is confusing the semantics of the data type with is syntax (encoding)</p>
<p>Raaz makes these types distinct and, to prevent accidental usage in ways unindented, makes these types opaque.</p>
</dd>
<dt><strong>Encoding:</strong></dt>
<dd>We do care about external presentation of cryptographic data captured by the data class <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Encode.html#t:Encodable" title="The class Encodable"><code>Encodable</code></a>. Almost all cryptographic data that has some encodable presentation is an instance of this type. An instance of <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Encode.html#t:Encodable" title="The class Encodable"><code>Encodable</code></a> can be converted to any of the supported binary formats. Currently only hex-encoding is supported but the git repository has Base64 encoding. The design of the encoding interface is done and adding a new encoding should not be difficult.
</dd>
<dt><strong>Equality in constant time:</strong></dt>
<dd>We ensure that all cryptographically sensitive data, like hashes have constant time equality comparisons, i.e. the time does not depend on whether the values are equal or not or by how many characters they match. We expose a class <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Types.html#t:Equality" title="Timing safe equality"><code>Equality</code></a> which aids in constructing such timing safe equality.
</dd>
<dt><strong>Multiple low level implementation:</strong></dt>
<dd>For cryptographic primitives, we support the use of multiple implementations. One of the goal of the design is to allow users to plugin their favorite implementation if the default one provided by the library was found lacking. However, this is an advanced feature and may need quite a bit of hacking.
</dd>
<dt><strong>Secure memory interface:</strong></dt>
<dd>We have an interface for secure memory, i.e. memory that is locked and will not be swapped. The library ensures that this memory is wiped clean after use. All implementations are designed to use this secure memory to store their sensitive internal state. See the module <a href="https://hackage.haskell.org/package/raaz-0.0.1/docs/Raaz-Core-Memory.html" title="Raaz: Secure memory"><code>Raaz.Core.Memory</code></a> in the library.
</dd>
<dt><strong>Documentation:</strong></dt>
<dd>We hope to have a well documented cryptographic library. In fact, quite a few students from IIT Kanpur have contributed to this project. I hope there is enough documentation in the source so that students can easily start working on it (as an academic I would like students to participate in such development efforts).
</dd>
</dl>
<p>For more details visit</p>
<ol style="list-style-type: decimal">
<li><p><a href="https://github.com/raaz-crypto/raaz">Our Repository</a></p></li>
<li><p><a href="https://hackage.haskell.org/package/raaz-0.0.1/" title="Haddock documentation for Raaz">Haddock documentation</a></p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>Je suis Charlie</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2015-01-09-Je-suis-Charlie.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2015-01-09-Je-suis-Charlie.html</id>
    <published>2015-01-09T00:00:00Z</published>
    <updated>2015-01-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Je parle un peu français mais had never heard of <a href="http://www.charliehebdo.fr/" title="Charlie Hebdo">Charlie Hebdo</a> before. I probably do not subscribe to your political views (I do not know). But there is one thing that I support: making the world a better place by reducing the influence of the arrogant religions of the world.</p>
<p>For too long they have been pampered with</p>
<ol style="list-style-type: decimal">
<li><p>the unquestioned right to take offence and vandalise,</p></li>
<li><p>the unquestioned right to spread their superstitions, despite modern science poking holes into all their theories about the universe.</p></li>
<li><p>the unquestioned right to pretend that they are the sole authority when it comes to goodness and ethics,</p></li>
<li><p>the unquestioned right to tax breaks.</p></li>
</ol>
<p>Not any more. Donc <a href="http://www.charliehebdo.fr/" title="Charlie Hebdo">“Je suis Charlie”</a></p>]]></summary>
</entry>
<entry>
    <title>Homotopy type theory at IITK</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2015-01-03-Homotopy-type-theory-at-IITK.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2015-01-03-Homotopy-type-theory-at-IITK.html</id>
    <published>2015-01-03T00:00:00Z</published>
    <updated>2015-01-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="http://www.andrew.cmu.edu/user/awodey/">Steve Awodey</a> is going to talk about <a href="http://www.homotopytypetheory.org" title="Homotopy type theory">homotopy type theory</a> at our department on 14th of January, 2015 at 3:00pm. This will be the 6th Hari V Sahasrabuddhe <a href="http://www.cse.iitk.ac.in/research/inflections/"><em>Inflections in Computing</em></a> lecture. The abstract is given below.</p>
<blockquote>
<p><em>Homotopy type theory</em> is a homotopical interpretation of a system of constructive type theory. It provides a new framework for the foundations of mathematics with intrinsic geometric content and a computational implementation. It is currently under intense development by logicians, mathematicians and computer scientists as a potential tool for both the large-scale formalization and verification of mathematical proofs and formal verification of software. In this survey talk, I will introduce this system and show how it can be used to give new logical proofs of some classical theorems from algebraic topology, making use of the new ideas of higher inductive types and the univalence axiom.</p>
<p>For information, see <a href="http://www.homotopytypetheory.org" class="uri">http://www.homotopytypetheory.org</a>.</p>
</blockquote>]]></summary>
</entry>
<entry>
    <title>Dependent types</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2014-08-27-Dependent-Types.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2014-08-27-Dependent-Types.html</id>
    <published>2014-08-27T00:00:00Z</published>
    <updated>2014-08-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we looked at simply typed lambda calculus where each term was associated with a type. As such the types of the language and terms were completely separated — we could define the types of the language independent of terms. A dependently typed language is one where the types can depend on values from a given type. For example consider the natural numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℕ</mi><annotation encoding="application/x-tex">ℕ</annotation></semantics></math>. In a language like Haskell, we can define them inductively. However, what if we want to capture the collection of residue classes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>n</mi></msub><annotation encoding="application/x-tex">ℕ_n</annotation></semantics></math> modulo a number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">n:ℕ</annotation></semantics></math>. Ideally, we would want to distinguish the types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>m</mi></msub><annotation encoding="application/x-tex">ℕ_m</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>n</mi></msub><annotation encoding="application/x-tex">ℕ_n</annotation></semantics></math> for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≠</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m ≠ n</annotation></semantics></math> — the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x + y</annotation></semantics></math> should lead to a type error if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><msub><mi>ℕ</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">x:ℕ_m</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><msub><mi>ℕ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y:ℕ_n</annotation></semantics></math>. A dependently typed language can supports construction of such types. For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>, a <em>type family</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a collection of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> one for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math>.</p>
<p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we saw that the type inference rules of simply typed lambda calculus gave us the rules of natural deduction for (a fragment of) propositional logic via the Curry-Howard isomorphism. To extend this to predicate logic, we would need a dependently typed lambda calculus as we explain now. Recall that we think of types as mathematical statements and elements of that type as proofs of the statements. Therefore, to capture predicates <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>, we need a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math>, i.e. we need a <em>type family</em> on A. As before, to prove the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> should mean constructing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y : P(a)</annotation></semantics></math>.</p>
<p>Given a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, which in the type theory world becomes a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, we need types that capture the logical formulae <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(x)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x∈A) P(x)</annotation></semantics></math>. This is done through the dependent sum (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>) and the dependent product (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>) types respectively.</p>
<h1 id="σ-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-types.</h1>
<p>For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, the <em>dependent sum type</em> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math> consists of all pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,x)</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x : P(a)</annotation></semantics></math>. The motivation is that proving the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math> for the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> <em>constructively</em> involves constructing a witness element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> for which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> is true. What more, in the constructive setting, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> being true has to be demonstrated by a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x:P(a)</annotation></semantics></math>. Thus elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A}P(a)</annotation></semantics></math> can be thought of as proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math>. Clearly if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A}P(a)</annotation></semantics></math> is not inhabited, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math> is not provable.</p>
<p>The ordinary product type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A × B</annotation></semantics></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) can be seen as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma_{a:A} P</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> is the type family that assigns <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> to every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. We can also define the ordinary sum type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∨ B</annotation></semantics></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>x</mi><mo>:</mo><mi>𝔹</mi></mrow></msub><mi>P</mi></mrow><annotation encoding="application/x-tex">Σ_{x:𝔹} P</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝔹</mi><annotation encoding="application/x-tex">𝔹</annotation></semantics></math> is the boolean type containing two values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="normal"><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mstyle><annotation encoding="application/x-tex">\mathrm{True}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="normal"><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mstyle><annotation encoding="application/x-tex">\mathrm{False}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> is the type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐟</mi></mstyle><mspace width="0.278em"></mspace><mi>x</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐧</mi></mstyle><mspace width="0.278em"></mspace><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐥</mi><mi>𝐬</mi><mi>𝐞</mi></mstyle><mspace width="0.278em"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">λ x . \mathbf{if}\; x\; \mathbf{then}\;A\;\mathbf{else}\;B</annotation></semantics></math>.</p>
<p>The first component of any element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math> gives an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. For types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> that do not have any inhabitants, it is impossible to construct element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math>. This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>∅</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈∅) P(x)</annotation></semantics></math> is false.</p>
<h1 id="π-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-types.</h1>
<p>The <em>dependenent product</em> (or the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a : A} P(a)</annotation></semantics></math> consists of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> whose value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math>. The motivation from the logical side is that a proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x∈A)P(x)</annotation></semantics></math> can be proved by giving a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> that takes every element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> to a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(a) : P(a)</annotation></semantics></math>. In agda, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a : A} P(a)</annotation></semantics></math> is denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">→</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a : A) → P(a)</annotation></semantics></math>.</p>
<p>Dependent type languages gives ways to construct functions in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a:A}P(a)</annotation></semantics></math> for any empty type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. For example, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>:</mo><mi>⊥</mi><mo accent="false">→</mo><mstyle mathvariant="normal"><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mstyle></mrow><annotation encoding="application/x-tex">P : ⊥ → \mathrm{Type}</annotation></semantics></math> is a type family we can create the function f in agda by using what is known as the <em>absurd pattern</em> (see line 2 below).</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">proof <span class="fu">:</span> (x <span class="fu">:</span> ⊥) <span class="ot">→</span> <span class="dt">P</span>(x) <span class="co">-- this is the dependent Π-type.</span>
proof ()               <span class="co">-- proof is defined using absurd pattern</span></code></pre></td></tr></table></div>
<p>This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>∅</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x:∅) P(x)</annotation></semantics></math> is true.</p>
<h1 id="the-vector-type-an-example-from-programming.">The <code>Vector</code> type: An example from programming.</h1>
<p>We now give an example of the famous vector type in agda used to captures lists of a particular length.</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span> <span class="fu">:</span> ℕ <span class="ot">→</span> <span class="dt">Type</span> <span class="kw">where</span>
	[]    <span class="fu">:</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="dv">0</span>
<span class="ot">	_::</span>_  <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> (a <span class="fu">:</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n)</code></pre></td></tr></table></div>
<p>Having defined such a type we can define the function <code>head</code> as follows</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">head <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span>} <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n) <span class="ot">→</span> <span class="dt">A</span>
head (<span class="ot">x ::</span> _) <span class="fu">=</span> x</code></pre></td></tr></table></div>
<p>One of the advantages of this definition of <code>head</code> is that it can never be applied to an empty vector. This is because the input type <code>Vector A (succ n)</code> of <code>head</code> can never match with the type of the empty vector <code>Vector A 0</code> and hence will lead to a compile time error.</p>
<h1 id="type-inference-rules.">Type inference rules.</h1>
<p>We now give a sketch of the type inference rules for dependently typed lambda calculus. As before typing any term requires to “know” the type of all the free variables in it. We capture this by judgements of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e:A</annotation></semantics></math>. However, unlike in the simply typed case, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> might itself have variables embedded in it. So not just the free variables in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> but all free variables that occur in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> should appear in the type assumption. Thus our strategy of defining types independent of terms like in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> will not work; we need to define them hand in hand.</p>
<p>The type assumptions themselves should now be an ordered sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> of assumptions of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> with the added restriction that for any assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> in the sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>, all the variables that appear free in the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> should themselves be defined in previous assumptions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>. Therefore the order of the assumptions in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> matters and they cannot be treated as mere sets. Such sequences will be called <em>telescopes</em> of type assumptions. Finally, we can form expressions like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x: A → e</annotation></semantics></math> only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is known to be a valid type which in turn depends on the telescope that is effective at that context. The inference rules for dependently typed lambda calculus thus needs to define <em>simultaneously</em> what the valid types, terms, telescopes and type judgements are. This we capture via the following judgements.</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow><annotation encoding="application/x-tex">e\;\mathbf{term}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a valid term,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> is a valid telescope,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">A\;\mathbf{type}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a valid type and finally</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e:A</annotation></semantics></math> which asserts that the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p></li>
</ol>
<p>We use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">ε</annotation></semantics></math> to denote the empty telescope. Any judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ \vdash \mathbf{something}</annotation></semantics></math> means that the judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle><annotation encoding="application/x-tex">\mathbf{something}</annotation></semantics></math> is valid under the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p>We write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">ε \vdash \mathbf{something}</annotation></semantics></math> as just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">\vdash \mathbf{something}</annotation></semantics></math> or even <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle><annotation encoding="application/x-tex">\mathbf{something}</annotation></semantics></math>. To reduce a lot of boiler plate, we sometimes drop certain preconditions if it can be deduced from the other preconditions. For example, we drop the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> if we also have a precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ ⊢ \mathbf{something}</annotation></semantics></math> latter on.</p>
<!--
  Besides these we have the special type $𝒰$ which we called the
  universe that stands of type of all types. Strictly speaking having
  such a type can make the logic inconsistent (Girard's paradox) but
  for simplicity we assume this.

  $$\frac{}{Γ ⊢ 𝒰\;\mathbf{type}}$$

  In all the above rules $Γ$ is any valid telescope (we have not
  defied what they are yet) and plays no important roles in the above
  rules. In fact, we can ignore $Γ$ and we have essentially just
  defined the types that we had in the previous. Dependent types will
  use these telescopes in a subtle way.

-->
<dl>
<dt><strong>Rules for telescopes</strong></dt>
<dd>The first rule that we have is that an empty sequence is a valid telescope.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow></mrow><mrow><mi>ε</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{}{ε\;\mathbf{telescope}}</annotation></semantics></math></p>
<p>The next inference rule says that we can add an assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> at the end of a valid telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> provided it is possible to infer that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type from the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\frac{\Gamma\;\mathbf{telescope};\; \Gamma \vdash
  A\;\mathbf{type}}{\Gamma, x:A\;\mathbf{telescope}} x ∉ Γ</annotation></semantics></math></p>
<p>We have slightly abused the notation in the expression of the side conditions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">x ∉ Γ</annotation></semantics></math> which essentially says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is <em>fresh</em>, i.e. does not occur in any assumptions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<dl>
<dt><strong>Formation rules for terms</strong></dt>
<dd>This essentially describes the syntax of our language.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>x</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\frac{}{x\;\mathbf{term}},</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>e</mi><mn>1</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow><mrow><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\frac{e_1\;\mathbf{term};\;e_2\;\mathbf{term}}
	{e_1e_2\;\mathbf{term}},</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ\;\mathbf{telescope};\; Γ ⊢ A\;\mathbf{type}}{Γ ⊢ λ x : A →
e\;\mathbf{term}}</annotation></semantics></math></p>
<p>The first two are essentially expressing the lambda calculus syntax for variables and application in the form of rules of inference. The last rule, however says that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x : A → e</annotation></semantics></math> is a valid term only if it is in the context of a telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type.</p>
<dl>
<dt><strong>Formation rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-types</strong></dt>
<dd>We have the following rules by which we can form types
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ ⊢ A\;\mathbf{type};\;Γ, x:A \vdash
		B\;\mathbf{type}} {Γ ⊢ Π_{x:A} B\;\mathbf{type}}</annotation></semantics></math></p>
<p>Notice that we omitted the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ,x : A \;\mathbf{telescope}</annotation></semantics></math> as mentioned before.</p>
<dl>
<dt><strong>Rules for type inferences</strong></dt>
<dd>We have a single variable rule followed by the introduction/elimination rules for the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-type.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ, x : A\;\mathbf{telescope}}{Γ,x : A ⊢ x : A}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>B</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mi>/</mi><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ ⊢ e_1 : Π_{x : A} B\; Γ ⊢ e_2 : A}{Γ ⊢ e_1 e_2 :
B[x/e_2]}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ, x : A ⊢ e : B}{Γ ⊢ (λ x : A → e) \; : Π_{x : A} B}</annotation></semantics></math></p>
<p>To incorporate the rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-types, we need to introduce a dependent pairing primitive and the corresponding pairing operations. We leave this as an exercise.</p>
<!--

$$\frac{Γ ⊢ A\;\mathbf{type};\;Γ, x:A \vdash
		B\;\mathbf{type}} {Γ ⊢ Σ_{x:A} B\;\mathbf{type}}$$
-->
<h1 id="where-are-the-dependent-types">Where are the dependent types?</h1>
<p>The dependently typed language we introduced here is mostly useless in the absence of any interesting types and type families. One strategy would be to introduce each type and type family by hand giving its, formation, introduction and elimination rules. At the very least, we fix a base set of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and add the formation rule <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>t</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{}{t\;\mathbf{type}} t ∈ 𝒯.</annotation></semantics></math> This will give us all the types described in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> (once we identify <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi_{x:A}B</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo accent="false">→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A → B</annotation></semantics></math> whenever <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not free in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>). To make dependently typed systems more useful actual systems supports construction of user defined types and type families. What these constructions are and what should be the restrictions on them has to be worked out. We defer this topic for the future.</p>]]></summary>
</entry>
<entry>
    <title>Typed lambda calculus</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2014-01-11-Typed-lambda-calculus.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2014-01-11-Typed-lambda-calculus.html</id>
    <published>2014-01-11T00:00:00Z</published>
    <updated>2014-01-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="in-memory-of-sanjeev-kumar-aggarwal-skaska.">In memory of <a href="http://cse.iitk.ac.in/users/ska" title="Sanjeev Kumar Aggarwal">Sanjeev Kumar Aggarwal (ska)</a>.</h2>
<p><strong>Update</strong>: An implementation of propositional logic in agada is available on my github repository <a href="https://github.com/piyush-kurur/sample-code/blob/master/agda/Logic.agda">sample-code/agda/Logic.agda</a></p>
<p>In this post, I briefly introduce typed lambda calculus in its simplest form and explain the type inference rules. The <a href="http://en.wikipedia.org/wiki/Curry-Howard_correspndence" title="Wikipedia: Curry-Howard correspndence">Curry-Howard isomorphism</a> appears for the first time here, although only for propositional logic.</p>
<h1 id="what-are-types">What are types ?</h1>
<p>We fix a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> of base types that can be thought of as the <em>built-in</em> types of the language. For this post, the set of types are all terms generated inductively as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex"> τ ≔ t ∈ 𝒯  | τ_1 → τ_2.</annotation></semantics></math></p>
<p>The above inductive definition means that a type is either a basic type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>, i.e. an element of the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math>, or it is the function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> are themselves types. The type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> captures the type of functions whose domain is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and range is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. There are few points that we want to clarify right away.</p>
<ol style="list-style-type: decimal">
<li><p>Consider the set of propositional logic formulas where the base set of propositions is <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and the only logical connective is the logical implies <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. There is a one-to-one correspondence with types of our language: interpret the functional type symbol <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math> as the implication operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. We will see in this post that this connection is <em>not</em> just skin deep.</p></li>
<li><p>The types in our language are defined independent of the terms in our lambda calculus. While this is possible for the version of typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus that we define here, when we want more powerful types this will no more be possible. We will have to define the values and types together.</p></li>
</ol>
<h1 id="what-is-a-well-typed-expression">What is a well typed expression ?</h1>
<p>Intuitively, a typed lambda calculus is a version of lambda calculus where each expression is assigned a <em>type</em>. This type is used to ensure that function application is of the correct type, i.e. whenever an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> is applied on another expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> <em>should be</em> a function type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">τ → τ′</annotation></semantics></math>, for type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">τ′</annotation></semantics></math>. This requires us to assign types to lambda calculus terms in a systematic way. We use the notation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> to assert that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Recall that a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term is a variable, or an application or a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. Therefore, we need to give systematic rules for assigning types for these three cases.</p>
<p>The base case would be to assign types to variables in an expression. We ensure that the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction also have to assert the type of the variable it quantifies. Thus, any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction is of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x:τ. e</annotation></semantics></math> and the bound variables <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> gets its type from this abstractions, i.e. every free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is assumed to be having the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. For the free variables, the only way we can have types is by <em>type assumptions</em>, a set of assertions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">x : τ</annotation></semantics></math>. The type of an expression thus depends on the type of the free variables in it. Therefore, a well typed lambda calculus expression should be a combination of an expression and a set of type assumption for the free variables in it. Furthermore, they should satisfy some additional rules which we call the <em>type inference rules</em>.</p>
<p>A <em>well typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression</em> is an ordered pair of (1) a type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> together with (2) a typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math>, written in the logical style <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e:τ</annotation></semantics></math>, subject to the following inference rules:</p>
<p>Variable Rule (<strong>VAR</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{}{Γ \cup \{ x : τ\} ⊢ x : τ}.</annotation></semantics></math></p>
<p>Rule for application (<strong>APP</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ f : τ_1 → τ_2;\;\; Γ ⊢ e : τ_1}{ Γ ⊢ f e : τ_2}.</annotation></semantics></math></p>
<p>Rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction (<strong>ABS</strong>) : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>∪</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ \cup \{x : τ_1\} ⊢ e : τ_2}{Γ ⊢ (λ x : τ_1 . e) : τ_1
	→ τ_2}.</annotation></semantics></math></p>
<p>The notation that we used for defining well typed terms is like a set of logical deduction rules. The stuff on the top of the horizontal line are <em>pre-conditions</em>, i.e. stuff which we already have derived, and the stuff in the bottom are <em>consequences</em>. i.e. stuff that can be concluded given the pre-conditions on the top. Let us now interpret each of these rules informally:</p>
<p><strong>VAR</strong> : This rule states that with no pre-conditions we can derive the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">x: τ</annotation></semantics></math> provided it is already an assumption. This rule takes care of the free variables in the expression.</p>
<p><strong>APP</strong> : This is the rules that makes sure that the functions are applied to the right arguments. It makes sure of two things (1) We are allowed to form the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> under the type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> if and only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> have types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> respectively under the assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> and (2) then the resulting expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p><strong>ABS</strong> : This rules assign types to the bound variables. This rule needs a bit of getting used to as we normally think in the other direction, i.e. in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x : τ_1 . e</annotation></semantics></math>, the occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math>.</p>
<p>In all the above rules, we assume that the type assumptions that arise on the left hand side of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>⊢</mo><annotation encoding="application/x-tex">⊢</annotation></semantics></math> symbol satisfies some obvious conditions like, no variables should have two distinct type assumptions etc.</p>
<h1 id="curry-howard-isomorphism.">Curry-Howard isomorphism.</h1>
<p>Recall that any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> can be seen as a proposition over the set of basic proportion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> by interpreting the function type operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math> as the Boolean implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math>. Consider the three type inference rules that we discussed and replace any type assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">x : σ</annotation></semantics></math> or type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e : τ</annotation></semantics></math> in the rules above with just the associated proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> respectively. This gives a set of inference rules for a restricted form of propositional logic that has implies operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">⇒</mo><annotation encoding="application/x-tex">⇒</annotation></semantics></math> as the only Boolean operator. This isomorphism between type inference and logical inference rules is often called the Curry-Howard isomorphism and is one of the main ideas of type theory. The goal in the rest of the post is to give a different interpretation of typed lambda calculus so that some magic is removed out of this isomorphism.</p>
<p>Consider the type assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math>. Normally, we think of types as a subset of allowed values and the assertion <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> as saying that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a value in the set associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. There is an alternate interpretation which makes the logical connection easy to make. Think of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> as a logical statement, proposition in this case. An assertion of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e: τ</annotation></semantics></math> is thought of as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> being the proof of the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Alternatively, we think of the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> as the set of all proofs of the proposition associated with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> in which case our usual interpretation means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">e:τ</annotation></semantics></math> means that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In this interpretation, a proof of the proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> should be treated a method to convert proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> to proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. This then gives a valid interpretation of all the rules of type inference as rules of building proofs.</p>
<p><strong>VAR</strong> : We can create a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> if we have such a proof by one of the assumption.</p>
<p><strong>APP</strong> : If <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> then it is a function that converts proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. If in addition, we have a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math>, we can apply <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> to it and get the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">f e</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>.</p>
<p><strong>ABS</strong> : If assuming a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> we were able to get a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> (which can make use of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> as an axiom) of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> then the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x: τ_1 . e</annotation></semantics></math> is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 → τ_2</annotation></semantics></math> as it takes any input proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and produces as output the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>:=</mo><mi>p</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">e[x := p]</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. Here <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mo>:=</mo><mi>p</mi><mo stretchy="false" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">e[x := p]</annotation></semantics></math> denotes replacing all free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.</p>
<p>This essentially is the crux of the “types as proofs” view point. If we want to effectively use this logical content of type theory, we need to look at richer and richer types and that is what we would be doing. We make some modest enriching in this post and leave the rest for future posts.</p>
<h2 id="introductionelimination-rules.">Introduction/Elimination rules.</h2>
<p>For the logical operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math>, the <strong>ABS</strong> rule serves as the <em>introduction</em> rule as its post-condition is an implication. Any proof of a formula that is essentially an implication therefore would have <strong>ABS</strong> as its last step. On the other hand <strong>APP</strong> serves the dual purpose. It is the <em>elimination</em> rule for the operator <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo accent="false">→</mo><annotation encoding="application/x-tex">→</annotation></semantics></math>. You may think of <strong>VAR</strong> rules as both an introduction as well as an elimination rule (it introduces nothing and eliminates nothing). This style of presentation of logical rules is due to Gentzen and plays an important role in designing type theoretic systems. The introduction rules gives ways to “construct” objects of a given type and elimination rules gives ways to “use” the objects in expressions. All other operators that we introduce here will also have introduction and elimination rules.</p>
<h1 id="the-operators-and-.">The operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math>.</h1>
<p>We would like our logic to have the conjunctions and disjunctions. At the type level we just need to add two additional type formation operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>. As a result our types are now inductively defined as:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo>≔</mo><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mi>.</mi></mrow><annotation encoding="application/x-tex"> τ ≔ t ∈ 𝒯 | τ_1 → τ_2 | τ_1 ∧ τ_2 | τ_1 ∨ τ_2.</annotation></semantics></math></p>
<p>To prove conjunctions and disjunctions, we need ways to create values (remember they are our proofs) of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∧ τ_2</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> respectively. For conjunctions, we introduce the primitive <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>.</mi><mo>,</mo><mi>.</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(.,.)</annotation></semantics></math> that pairs up two expressions to give a new expression. A value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> can be created in two ways: by applying the <em>constructor</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inl}</annotation></semantics></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> or by applying the constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inr}</annotation></semantics></math> on a value of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. These give the required introduction rules for the logical operators <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>:</p>
<p><strong>DISJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1}{Γ ⊢ \mathbf{inl}\; e \;: τ_1 ∨ τ_2},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_2}{Γ ⊢ \mathbf{inr} \;e \;: τ_1 ∨ τ_2}.</annotation></semantics></math></p>
<p><strong>CONJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo>,</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e_1 : τ_1;\; Γ ⊢ e_2 : τ_2}
		{Γ ⊢ (e_1,e_2) : τ_1 ∧ τ_2}.</annotation></semantics></math></p>
<p>The justification of these rules from a proof theoretic point of view is that one can give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∧ τ_2</annotation></semantics></math> by giving a <em>pair</em> of proofs where the first component is a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> and the second a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math>. Similarly, we give a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">τ_1 ∨ τ_2</annotation></semantics></math> by giving either a proof of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>1</mn></msub><annotation encoding="application/x-tex">τ_1</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>τ</mi><mn>2</mn></msub><annotation encoding="application/x-tex">τ_2</annotation></semantics></math> except that we need to explicitly state which is the case by using the appropriate constructor <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐥</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inl}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐧</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{inr}</annotation></semantics></math>.</p>
<p>Next we give the elimination rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∧</mo><annotation encoding="application/x-tex">∧</annotation></semantics></math>. The corresponding language primitive that we need is the projection operators which we add as built in functions in our calculus.</p>
<p><strong>PROJ</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐬</mi><mi>𝐭</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>1</mn></msub></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1 ∧ τ_2}{Γ ⊢ \mathbf{fst}\; e \; :\; τ_1},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∧</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐧</mi><mi>𝐝</mi></mstyle><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex">
	\frac{Γ ⊢ e : τ_1 ∧ τ_2}{Γ ⊢ \mathbf{snd}\;e \;:\; τ_2}.</annotation></semantics></math></p>
<p>Similarly, to obtain the elimination rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>∨</mo><annotation encoding="application/x-tex">∨</annotation></semantics></math>, we add the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐢</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐫</mi></mstyle><annotation encoding="application/x-tex">\mathbf{either}</annotation></semantics></math> that does case by case analysis.</p>
<p><strong>CASE</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo>∨</mo><msub><mi>τ</mi><mn>2</mn></msub><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>l</mi><mo>:</mo><msub><mi>τ</mi><mn>1</mn></msub><mo accent="false">→</mo><mi>τ</mi><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>r</mi><mo>:</mo><msub><mi>τ</mi><mn>2</mn></msub><mo accent="false">→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐢</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐫</mi></mstyle><mspace width="0.278em"></mspace><mi>l</mi><mspace width="0.278em"></mspace><mi>r</mi><mspace width="0.278em"></mspace><mi>e</mi><mspace width="0.278em"></mspace><mo>:</mo><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ e : τ_1 ∨ τ_2;\;Γ ⊢ l : τ_1 → τ;\; Γ ⊢ r : τ_2 → τ}
		{Γ ⊢ \mathbf{either}\;l\;r\;e\;:τ}.</annotation></semantics></math></p>
<p>We define the the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo accent="false">↔</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">σ ↔ τ</annotation></semantics></math> of logical equivalence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>σ</mi><mo accent="false">→</mo><mi>τ</mi><mo stretchy="false" form="postfix">)</mo><mo>∧</mo><mo stretchy="false" form="prefix">(</mo><mi>τ</mi><mo accent="false">→</mo><mi>σ</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(σ → τ) ∧ (τ → σ)</annotation></semantics></math>.</p>
<h1 id="truth-falsity-and-negation.">Truth, falsity and negation.</h1>
<p>We have a proof theoretic view of truth and falsity in this setting. Propositions are “true” if they can be proved by giving a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression of that type and not true otherwise. In that sense, we only have “truths” and “not truths” and every inhabited types, i.e. types for which we can construct an element with that type, is true. Explicit truth and falsity can be achieved by adding types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> to the basic types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and to make <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math> provable, we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus with a single constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊤</mi><annotation encoding="application/x-tex">⊤</annotation></semantics></math>. That there is no constants with type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> is deliberate design choice as we do not want to prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math> in our logic. Once we have the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math>, we can define the negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">¬ τ</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> to be the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>⊥</mi></mrow><annotation encoding="application/x-tex">τ → ⊥</annotation></semantics></math>.</p>
<p>The <em>law of excluded middle</em>, LEM for short, is the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">↔</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ ↔ ¬ ¬ τ</annotation></semantics></math> and is <em>not</em> a basic axiom of our logic. We can in fact prove one direction <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → ¬ ¬ τ</annotation></semantics></math>: Consider the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>f</mi><mi>.</mi><mi>f</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x f . f x</annotation></semantics></math>. It is easy to see that we can assign to it the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mo stretchy="false" form="prefix">(</mo><mi>τ</mi><mo accent="false">→</mo><mi>σ</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">→</mo><mi>σ</mi></mrow><annotation encoding="application/x-tex">τ → (τ → σ) → σ</annotation></semantics></math> for any types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In particular, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">σ</annotation></semantics></math> is the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>⊥</mi><annotation encoding="application/x-tex">⊥</annotation></semantics></math>, we have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → ¬¬τ</annotation></semantics></math>. The converse however is not provable. This might be considered as a weakness of the logic because LEM is used through out mathematics. However, there is a distinct advantage here.</p>
<ol style="list-style-type: decimal">
<li><p>The proofs that we build are <em>constructive</em> and</p></li>
<li><p>If we are in dire need of the opium called LEM, we can recover it by adding a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math> of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">↔</mo><mi>¬</mi><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ ↔ ¬¬ τ</annotation></semantics></math> the way we added the constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math>. However, this is never done in practice when using a proof assistant like <code>coq</code> or <code>agda</code></p></li>
</ol>
<h1 id="comparison-to-untyped-λ-calculus.">Comparison to untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus.</h1>
<p>For any typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e : τ</annotation></semantics></math> we can get an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus term, denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> itself, by ``erasing’’ out all types from abstractions. Is it possible to do the other way? Can we assign types to an untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus expression in a way that is consistent to the rules defined above? Doing this algorithmically is the type inference problem. For example, consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x . x</annotation></semantics></math>. Intuition tells us that this can be assigned any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → τ</annotation></semantics></math> as it is the identity function. Indeed this is the case:</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo>:</mo><mi>τ</mi><mo stretchy="false" form="postfix">}</mo><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">\{x : τ\} ⊢ x : τ</annotation></semantics></math> by <strong>VAR</strong></p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">⊢ (λ x : τ . x) : τ → τ</annotation></semantics></math> by <strong>ABS</strong> and (1).</p></li>
</ol>
<p>It turns out that not all terms can be consistently typed, for example <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λ x . xx</annotation></semantics></math> cannot be assigned any type (why?).</p>
<p>Recall that the computational content of untyped <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus is captured in the notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction. To avoid variable collision we also need <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversions. It is easy to see that notion of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction can be defined in a straight forward way for typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus. What then is the difference? The typed version of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction is <em>strongly normalising</em>. It turns out that term like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Ω</mi><mo>=</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Ω= (λx . xx) (λx .xx)</annotation></semantics></math> and fixed point combinators cannot be consistently typed. As a result general recursion, and hence infinite loops, are <em>not</em> possible in this calculus.</p>
<h1 id="consistency-and-recursion">Consistency and recursion</h1>
<p>The Curry-Howard isomorphism gives us a way to define logical system out of typed lambda calculus. Enriching the basic typed lambda calculus with constants like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math> is like adding axioms to the logical system assoicated with the language. In any logical system, we need to worry about consistency. In classical logic, a set of axioms together with the inference rules form an <em>inconsistent</em> system if one can prove a statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> and its negation <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>¬</mi><mi>τ</mi></mrow><annotation encoding="application/x-tex">¬τ</annotation></semantics></math>. This definition is not very useful in the type theoretic setting as it is crucially dependent on negation which we want to avoid as much as possible. An alternate way to define inconsistency is to define inconsistent system as those which proves all statements. It is this definition of inconsistency that is easier to work with in the type theoretic framework. We say that a type theoretic system, i.e. the under lying typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus and its type inference rules, is <em>inconsistent</em> if <em>every</em> type in <em>inhabited</em>. This makes sense because an inhabitant of a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> is the proof of the statement (associated) to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. In this section, we want to connect consistency and the ability to do recursion. In fact, arbitrary recursion, or equivalently a uniform way to compute fixed points, is dangerous from a consistency perspective.</p>
<p>We saw that the typed <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus that we defined does not support fixed point combinators and therefore does not support recursion. This severely limits the kind of programs that one can write in such a language. However, we <em>do</em> know that fixed points can be implemented on a computer. Can we enrich the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus to include a fixed point combinator by force? After all, we do know how to compile it into machine code. What would happen if we just enrich the calculus with a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><annotation encoding="application/x-tex">\mathbf{fix}</annotation></semantics></math>, much like the way we included a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐨</mi><mi>𝐛</mi><mi>𝐯</mi><mi>𝐢</mi><mi>𝐨</mi><mi>𝐮</mi><mi>𝐬</mi></mstyle><annotation encoding="application/x-tex">\mathbf{obvious}</annotation></semantics></math> or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐥</mi><mi>𝐞</mi><mi>𝐦</mi></mstyle><annotation encoding="application/x-tex">\mathbf{lem}</annotation></semantics></math>. For this to workout, we would need to augment our type inference rules with the following rule for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><annotation encoding="application/x-tex">\mathbf{fix}</annotation></semantics></math></p>
<p><strong>FIX</strong> : <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>f</mi><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>f</mi><mspace width="0.278em"></mspace><mo>:</mo><mspace width="0.278em"></mspace><mi>τ</mi></mrow></mfrac><mi>.</mi></mrow><annotation encoding="application/x-tex"> \frac{Γ ⊢ f : τ → τ}
		{Γ ⊢ \mathbf{fix}\;f\;:\; τ}.</annotation></semantics></math></p>
<p>This would mean that, if we some how create a function of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>:</mo><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">f:τ→τ</annotation></semantics></math> then we can prove <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> using the proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>f</mi></mrow><annotation encoding="application/x-tex">\mathbf{fix}\; f</annotation></semantics></math>. Recall that, for any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>, the typed lambda calculus expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>τ</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">I = λ x : τ . x</annotation></semantics></math> has type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>τ</mi><mo accent="false">→</mo><mi>τ</mi></mrow><annotation encoding="application/x-tex">τ → τ</annotation></semantics></math>. Taking its fixed point <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathvariant="bold"><mi>𝐟</mi><mi>𝐢</mi><mi>𝐱</mi></mstyle><mspace width="0.278em"></mspace><mi>I</mi></mrow><annotation encoding="application/x-tex">\mathbf{fix}\; I</annotation></semantics></math> will give an inhabitant of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>. Therefore, adding arbitrary fixed points will make the logic inconsistent.</p>
<p>Real world programming languages like Haskell does not care about this issue as writing infinite loops are too important for a programmer. In fact, every type in Haskell has an inhabitant, namely <code>undefined</code>. What this means is that the type system of Haskell is not directly suitable as a theorem prover although we can still use it to catch many bugs at compile time.</p>
<p>Languages like agda which has to double up as a proof assistant allow certain restricted kinds of recursion by making sure that the recursion is well formed. Other than the motivation to write real world programs, some restricted form of recursion is actually necessary to capture mathematical objects like natural numbers etc. We leave these issues for future posts.</p>]]></summary>
</entry>
<entry>
    <title>Travis builds for Raaz</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-11-08-Travis-builds-for-raaz.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-11-08-Travis-builds-for-raaz.html</id>
    <published>2013-11-08T00:00:00Z</published>
    <updated>2013-11-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post describes the structure of <a href="https://travis-ci.org" title="Travis CI">travis</a> CI system in place for <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a>, the cryptographic network library for <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> that we are developing. This documents some of its tricky aspects and what more needs to be done.</p>
<p>If you are not familiar with <a href="https://travis-ci.org" title="Travis CI">travis</a> CI please check it out. The tight integration of <a href="https://travis-ci.org" title="Travis CI">travis</a> with <a href="https://github.com" title="Github">github</a> means every push to the repository is built and checked. What more, the system also builds every pull requests, so before merging I can be sure that stuff works. Having said that there are certain limitation of <a href="https://travis-ci.org" title="Travis CI">travis</a> builds particularly in the context of <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> which I list below.</p>
<ol style="list-style-type: decimal">
<li><p>The travis builds are done on an <a href="http://www.ubuntu.com" title="Ubuntu">Ubuntu</a> container. Therefore, the default builds are against whatever haskell platform comes with it. Thanks to <a href="https://github.com/hvr" title="Herbert Valerio Riedel">Herbert Valerio Riedel</a> for his <a href="https://github.com/hvr/multi-ghc-travis">write up</a> and his <a href="https://launchpad.net/~hvr/+archive/ghc" title="Herbert V Riedel's Ubuntu PPA">Ubuntu ppa</a>, we now build across multiple haskell platform. The instructions need to be tweaked though as they assume that repository is a single directory with the package in the root directory. I have described this in the next section. This therefore is mostly solved.</p></li>
<li><p>Since I myself use <a href="http://www.debian.org" title="Debian">Debian</a> stable and <a href="https://travis-ci.org" title="Travis CI">travis</a> uses <a href="http://www.ubuntu.com" title="Ubuntu">Ubuntu</a>, there is not much cross OS builds. Ideally I would want it to be built on at least few of the BSD variants.</p></li>
<li><p>The builds happen only on one architecture, the architecture that the <a href="https://travis-ci.org" title="Travis CI">travis</a> build runs on. While this is not a problem for most packages, <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> being a cryptographic library should be built across multiple architecture. Only then can we catch bugs due to endian mismatch, alignment problems (ARM in particular). This becomes all the more important when we start including architecture specific implementations of primitives.</p></li>
</ol>
<p>I think (2) should be easy to solve. Someone with more BSD experience can help out on this. I think (3) is particularly difficult because we need actual hardware to test it out. One option would be to build it and run on an emulator like <a href="http://www.qemu.org" title="QEMU processor emulator">qemu</a>. However, I do not know of any build system that makes this easy. On the other hand OS distributions like <a href="http://www.debian.org" title="Debian">Debian</a> should have solved this problem. I would like advice from some knowledgeable person here.</p>
<h1 id="multi-platform-build-raazs-idiosyncracies.">Multi-platform build: Raaz’s idiosyncracies.</h1>
<p>The <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">raaz</a> repository is a collection of haskell packages with dependencies between them. So <a href="https://github.com/hvr/multi-ghc-travis">Riedel’s instructions</a> do not work directly. We need to make sure that</p>
<ol style="list-style-type: decimal">
<li><p>To build a package we need to be in its root directory. This involves cd’ing into the directory and essentially following <a href="https://github.com/hvr/multi-ghc-travis">Riedel’s instructions</a></p></li>
<li><p>Before installing a package like <a href="https://github.com/piyush-kurur/raaz/blob/master/raaz-hash-sha"><code>raaz-hash-sha</code></a>, we need to install all its dependencies within the raaz collection as those packages are not on cabal. We use <code>make</code> to ensure these.</p></li>
</ol>
<p>I have documented most of this in the <a href="https://github.com/piyush-kurur/raaz/blob/master/Makefile"><code>Makefile</code></a> which you might want to refer to. Let me know if the documentation needs improvements.</p>
<h2 id="package-version-subtleties.">Package version subtleties.</h2>
<p>There is a subtle problem with dependencies that makes multi-platform builds more or less meaningless. The way we ensure that the packages are built against a platform is by setting up an appropriate <code>cabal.config</code> file in the directory of the package. This config file puts constraints corresponding to the platform we want to test against. I noticed that the builds are actually not installing the platform packages because of the version dependency. For example, the dependency on Quickcheck that we had was <code>Quickcheck==2.4.*</code>. This means that even for builds for <a href="https://www.haskell.org/platform/changelog.html">platform 2013.2.0.0</a> the quick package used was <code>Quickcheck-2.4.something</code>. For this reason we had to go for a more liberal package version bounds (merge <a href="https://github.com/piyush-kurur/raaz/commit/ac0ad7afd711b656a77257ebc4ba923cb939b3f3">ac0ad7</a>). As long as we are not using the packages like <code>base</code> or <code>Quickcheck</code> in a non-standard way, I think we are fine.</p>]]></summary>
</entry>
<entry>
    <title>Lambda calculus</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-11-04-Lambda-calculus.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-11-04-Lambda-calculus.html</id>
    <published>2013-11-04T00:00:00Z</published>
    <updated>2013-11-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>We begin the exploration of type theory by describing lambda calculus. This post is mostly to set up the notation and the standard reference for material here is the encyclopedic book <a href="http://mathgate.info/cebrown/notes/barendregt.php" title="The Lambda Calculus: Its syntax and semantics">The lambda calculus: Its syntax and semantics</a>. Also have a look on <a href="http://en.wikipedia.org/wiki/Lambda_calculus" title="Wikipedia: Lambda calculus">Wikipedia</a> for details and references.</p>
<p>The core idea of lambda calculus is an elegant notation invented by <a href="http://en.wikipedia.org/wiki/Alonzo_Church" title="Wikipedia: Alonzo Church">Alonzo Church</a> to capture functions without naming them. Consider the function that increments its argument by 1. In notation of lambda calculus one can write such an increment function as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">λ x . x + 1</annotation></semantics></math> (assuming of course that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math> has already been defined). This notation has now found its way to many programming languages like Haskell (<code>\ x -&gt; x + 1</code> the backslash is an <a href="http://en.wikipedia.org/wiki/ASCII" title="Wikipedia: ASCII">ASCII</a> approximation of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>), python (<code>lambda x: x + 1</code>) etc. The lambda calculus we deal with here does not have the <em>built-in</em> function like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mo>+</mo><annotation encoding="application/x-tex">+</annotation></semantics></math>. All it has is a (countably infinite) supply of variables, which we will denote by small case letters <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> etc and two fundamental operation namely application and abstraction. The lambda calculus expressions can be inductively defined as follows:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>=</mo><mi>x</mi><mo stretchy="false" form="prefix">|</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="prefix">|</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>e</mi></mrow><annotation encoding="application/x-tex"> e = x | e_1 e_2 | λ x . e</annotation></semantics></math></p>
<p>In the above inductive definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is any one of the countably infinite variables and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>1</mn></msub><annotation encoding="application/x-tex">e_1</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>e</mi><mn>2</mn></msub><annotation encoding="application/x-tex">e_2</annotation></semantics></math> are lambda calculus expressions defined recursively. We will follow that standard convention that all application associates to the left (i.e. <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>g</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">f g h</annotation></semantics></math> means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mi>g</mi><mo stretchy="false" form="postfix">)</mo><mi>h</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">((f g) h)</annotation></semantics></math>) and that application binds tighter than <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. Further, the the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λxy.xy</annotation></semantics></math> means <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>λ</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx . λy . xy</annotation></semantics></math>.</p>
<h1 id="free-and-bound-variables.">Free and bound variables.</h1>
<p>The lambda abstraction acts like any other mathematical quantifier when it comes to determining the free and bound variables. An occurrence of a variable in a expression is either free (i.e. is not in the scope of any <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction) or is bound to a lambda abstraction. If an occurrence of a variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is in the scope of more than one <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction then it is bound to the inner most one. For example in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx.xy</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is bound and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> is free. One can define the notion of free variables inductively as follows.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">FV(x)       = \{ x\},</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>∪</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">)</mo><mo>,</mo></mrow><annotation encoding="application/x-tex">FV(e_1 e_2) = FV(e_1) ∪ FV(e_2),</annotation></semantics></math> <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mi>F</mi><mi>V</mi><mo stretchy="false" form="prefix">(</mo><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mo>∖</mo><mo stretchy="false" form="prefix">{</mo><mi>x</mi><mo stretchy="false" form="postfix">}</mo><mi>.</mi></mrow><annotation encoding="application/x-tex">FV(λx . e)  = FV(e) ∖ \{x \}.</annotation></semantics></math></p>
<p>As in other mathematical notations, the meaning of a lambda calculus expression depends only on the free variables, which means one can change the bound variables of an expression. For example the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx . xy</annotation></semantics></math> is the same as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>t</mi><mi>.</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λt. t y</annotation></semantics></math>. This change of bound variables is called <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion. When doing an <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion however, care must be taken to avoid variable bindings to be inadvertently changed. For example in the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λx.xy</annotation></semantics></math>, the variable x cannot be changed to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> as it is occurs free and changing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> will make it bound. One can avoid such a situation if we always use fresh variables. We will assume from now on that all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-conversion takes care of this problem.</p>
<h1 id="β-reductions"><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions</h1>
<p>The computational power of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-calculus comes from what is known as <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions which formalises the notion of the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>λ</mi><annotation encoding="application/x-tex">λ</annotation></semantics></math>-abstraction. The essence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction is that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">(λx. M)N</annotation></semantics></math>, under <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction, reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>′</mi></mrow><annotation encoding="application/x-tex">M'</annotation></semantics></math> is the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> with all <em>free</em> occurrences of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> replaced by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>. However, we have to be careful to take care that no free variable in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> gets inadvertently bound as a result. For example consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mi>λ</mi><mi>y</mi><mi>.</mi><mi>x</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">M = λy.xy</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">N=y</annotation></semantics></math>. If we blindly reduce <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>M</mi><mo stretchy="false" form="postfix">)</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">(λx.M) N</annotation></semantics></math> then the free variable <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> gets bound. This is because a free occurrence of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> comes in the scope of a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">λy</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math> happens to be free in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>. To avoid this problem one can <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">α</annotation></semantics></math>-convert the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> to use a new bound variable instead of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>y</mi><annotation encoding="application/x-tex">y</annotation></semantics></math>. We assume from now on that each such <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduction carefully avoids the free variable capture.</p>
<p>A <em><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-normal form</em> is an expression for which there are no more <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions possible. For example a variable is a normal form so is expressions of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λx.x</annotation></semantics></math>. One can think of this as a program that has terminated. We say that an expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>M</mi><annotation encoding="application/x-tex">M</annotation></semantics></math> <em>has</em> a normal form if there is normal form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> to which it can be reduced after a series of finitely many <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reductions. Expressions might have a normal form or can diverge and it is <em>undecidable</em> to check which is the case. However, a consequence of the <a href="http://en.wikipedia.org/wiki/Church-Rosser_theorem" title="Wikipedia: Church-Rosser theorem">Church-Rosser theorem</a> is that if an expression has a normal form then it should be unique.</p>
<p>A <em>reduction strategy</em> is an algorithm to choose which sub-term of a lambda calculus expression should be <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduced next. Clearly there is no strategy that will terminate always as there are terms which do not have a normal form. Can we have a strategy which will guarantee termination if the expression has a normal form? Fortunately the <em>normal order</em> evaluation strategy is normalising, i.e. it finds a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-normal form if it exists (See <a href="http://en.wikipedia.org/wiki/Lambda_Calculus" title="Wikipedia: Lambda Calculus">Lambda Calculus</a> for more details). Therefore, the problem of finding the normal form is <em>partially recursive</em> in the sense that one can write a program to compute the normal form of an expression if it has one.</p>
<h1 id="fixed-points-and-recursion">Fixed points and recursion</h1>
<p>It might not appear so but hidden inside the simplicity of lambda calculus is a full fledged programming language. With appropriate encoding of natural numbers (see for example <a href="http://en.wikipedia.org/wiki/Church_encoding" title="Wikipedia: Church encoding">Church encoding</a>) one can represent all computable functions. This is the Church-Turing hypothesis. While we do not want to go into the details of this, we will show how to implement one important feature namely recursive definition of functions.</p>
<p>An important property of untyped lambda calculus is that every lambda calculus function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math> has a <em>fixed point</em>: given <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>, consider the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>=</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">X = λx. F(xx)</annotation></semantics></math>. One can easily show that the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>X</mi></mrow><annotation encoding="application/x-tex">XX</annotation></semantics></math> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>β</mi><annotation encoding="application/x-tex">β</annotation></semantics></math>-reduces to <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>X</mi><mi>X</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">F(XX)</annotation></semantics></math> and is therefore the fixed point of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. Furthermore, the computation of fixed point is effective as well, i.e. we have a lambda calculus combinator for computing it: Consider for example the combinator (i.e. lambda calculus term with no free variable) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math> defined as <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>λ</mi><mi>f</mi><mi>.</mi><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mi>.</mi><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mi>x</mi><mo stretchy="false" form="postfix">)</mo><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Y = λf . (λx . f(xx))(λx. f(xx))</annotation></semantics></math> It is easy to verify that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">YF</annotation></semantics></math> is the fixed point for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. Existence of fixed point combinator is important as that is what allows us to define functions recursively. A recursive definition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo>=</mo><mi>F</mi><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f = F(f)</annotation></semantics></math> is nothing but the fixed point of the function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>F</mi><annotation encoding="application/x-tex">F</annotation></semantics></math>. The fact that it is effective make it possible for the compiler to support recursive functions. Fixed point theorem also allows mutual recursion. For this one has to have a way of <em>pairing</em> values into tuples which can be done in lambda calculus by suitable encoding (see the <a href="http://en.wikipedia.org/wiki/Lambda_calculus#Pairs" title="Wikipedia: Lambda calculus#Pairs">Lambda calculus#Pairs</a>). The reset of the details I leave it as an exercise.</p>]]></summary>
</entry>
<entry>
    <title>Types, proofs and programming.</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-10-18-Type-theory-series.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-10-18-Type-theory-series.html</id>
    <published>2013-10-18T00:00:00Z</published>
    <updated>2013-10-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>For quite some time, I have been toying with the idea of trying to get a grip on the various beautiful ideas that go under the name <em>type theory</em>. It looks to me that the time has come for a deep dive into the <a href="http://homotopytypetheory.org" title="Homotopic Type Theory">hott</a> (no this is definitely not a typo) waters. This is the first in a series of posts on type theory and its various ramifications to Functional programming and foundations of mathematics. I am not an expert in this area but by blogging I hope to gain the insights that has eluded me so far.</p>
<p>This particular blog post also will serve as a “Table of Contents” for the series. While all the posts in this series will have the “<a href="../posts/tags/Type%20theory.html" title="Posts on Type theory">Type theory</a>” tag in it, the explicit listing of the contents serves as a suggested order in which to read the posts.</p>
<h1 id="perspective.">Perspective.</h1>
<p>In a sufficiently rich functional programming language (like for example Haskell), we have <em>expressions</em> each of which are associated with a <em>type</em>. The types can be seen as <em>invariants</em> that the expressions satisfy through out the program. For example, when you assert that the variable <code>x</code> has type <code>Int</code>, you are implicitly asking the compiler to make sure that <code>x</code> is used in ways that are consistent to the fact that it is an integer. Checking this invariant at compile time ensures that the programmer does not introduce silly bugs like trying to add <code>2</code> to <code>&quot;hello&quot;</code> etc. Thus there is some amount of <em>theorem proving</em>, rather trivial in the above case, already built into any strongly typed language. This informal connection can be formalised via what is know as the Curry-Howard Isomorphism which observes that the rules for assigning well defined types to expressions coincide remarkably with rules for proving statements in a suitable logic. For any type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math> one can associate a statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>τ</mi></msub><annotation encoding="application/x-tex">A_τ</annotation></semantics></math> such that if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a well typed expression of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">τ</annotation></semantics></math>, we can map <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>, rather the derivation of the type of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math>, to a proof of the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mi>τ</mi></msub><annotation encoding="application/x-tex">A_τ</annotation></semantics></math>. The precise statement of this connection is left for later posts but the core idea here is that <em>type checking</em> is essentially <em>proof checking</em> (and vice-versa).</p>
<p>Why is this connection interesting? In order to fully see the <a href="http://en.wikipedia.org/wiki/Blind_men_and_an_elephant" title="Wikipedia: Blind men and an elephant">type theory elephant</a>, we often need to acquire the split personalities of a programmer (functional programmer) and a mathematician.</p>
<p>The programmer is actually interested in the expressions, as they are the programs. Types are a way of ensuring that the programs satisfy certain invariants. The stronger the type system, the larger is the class of invariants that can be expressed. Thus for her the types are a means to achieve correct programs. The holy grail in this line of thought is to have completely machine certified programs. A full fledged programming language which implements such types can thus be its own specification language.</p>
<p>The mathematician is more interested in the types as they correspond to mathematical truths. Expressions are just proofs of these statements. The functional programming language with sufficiently powerful types can thus be used as a proof assistant to achieve completely automated mathematical proof checking. However, proofs being values are now first class values. Much like in a functional programming language, where making functions first class values helped in a lot of simplification and abstraction, it is hoped that making proofs first class can give ways to manipulate and think about them which traditional mathematics could not.</p>
<p>The above two viewpoint have sometimes slightly conflicting goals. A programmer is concerned in the performance of these languages. There are certain technical issues like the fact that all function should terminate if one wants to avoid inconsistency that can be a show stopper in writing non-terminating programs like servers etc. The mathematician however is not much bothered about the actual efficiency of the running code. However, issues like consistency and termination is important. After all who wants a proof assistant that will accept all proofs.</p>
<h1 id="contents">Contents</h1>
<ol style="list-style-type: decimal">
<li><a href="../posts/2013-11-04-Lambda-calculus.html">Lambda Calculus</a></li>
<li><a href="../posts/2014-01-11-Typed-lambda-calculus.html">Typed lambda calculus</a></li>
<li><a href="../posts/2014-08-27-Dependent-Types.html">Dependent Types</a></li>
</ol>]]></summary>
</entry>
<entry>
    <title>Raaz: A cryptographic network library for Haskell</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-08-24-Raaz-A-cryptographic-network-library.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-08-24-Raaz-A-cryptographic-network-library.html</id>
    <published>2013-08-24T00:00:00Z</published>
    <updated>2013-08-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is my first post on <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a>, a cryptographic network library for <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a>. <a href="http://github.com/raaz-crypto/raaz" title="Raaz: A Cryptographic Network library for Haskell">Raaz</a> broadly aims at developing into:</p>
<ol style="list-style-type: decimal">
<li><p>A platform to experiment with various cryptographic primitives.</p></li>
<li><p>A library to write high performance servers and clients to some common cryptographic network protocols.</p></li>
</ol>
<p>I believe that <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> as a language has a lot of features that allow writing fast (as fast or better than any <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> library available) as well as secure cryptographic code. In this post, I attempt to explain some of the features of <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> that we make use of.</p>
<h1 id="speed">Speed</h1>
<p>Let me first dispose of the one myth that seems to persist in the mind of people who have never seen a modern functional language. No one wants their software to be slow. Cryptographic protocols should be especially well implemented otherwise folks would simply avoid using the secure options. Clearly when it comes to performance <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> can beat any of the interpreted languages <a href="http://www.python.org">Python</a>, <a href="http://www.ruby-lang.org">Ruby</a> or <a href="http://en.wikipedia.org/wiki/Java_%28programming_language%29">Java</a>. But what about <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>?</p>
<p>The tight loops in the library which implements the primitives will anyway be written in <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>/Assembly. If one wants speed then one needs to do this whether one likes it or not. So for primitives it really does not matter which language one chooses. It then boils down to how easy it is to integrate <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>/Assembly code with <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a>. Having a low overhead foreign function Interface (FFI) is really critical here and Haskell fortunately has it.</p>
<p>Having fast primitives helps but a network library is not just a set of fast cryptographic primitives. Here are some of the features that one would.</p>
<ol style="list-style-type: decimal">
<li><p>High performance concurrency primitives for server applications. <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> really has no competition in this department. Here are some of the features that GHC (and libraries) supports: <a href="http://en.wikipedia.org/wiki/Green_threads" title="Wikipedia: Green threads">Green threads</a> <a href="http://www.haskell.org/haskellwiki/Software_transactional_memory">STM</a>s, <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html">MVar</a>s etc. Using these features, servers written in <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> have been competitive (often outperforming) servers written is <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>. See for example <a href="http://mew.org/~kazu/proj/mighttpd/en/">mighttpd</a>.</p></li>
<li><p>Efficient data serialisation and parsing libraries: Implementing the wire protocol efficiently is critical in improving the efficiency of the network application. <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> is especially rich in this department as well: <a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a>, <a href="http://hackage.haskell.org/package/binary">binary</a>, <a href="http://hackage.haskell.org/package/blaze-builder">blaze-builder</a> etc. There are libraries that supports high performance (close to hand written <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> performance) at the same time achieving these feats at a much higher level of abstraction (which translates to less bugs and high maintainability).</p></li>
</ol>
<p>While having fast libraries is great, languages like <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> achieve this at the cost of abstraction. It often appears to the programmer that one needs to sacrifice elegance for speed. Not so with <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a>. Many of the libraries I mentioned above achieve <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a> speed with no compromise on the level of abstraction. This greatly enhances the maintainability and leads us to the next important feature that we want in our libraries, safety.</p>
<h1 id="safety.">Safety.</h1>
<p>Cryptographic implementations are full of corner cases and the bugs in them can be particularly lethal. A cryptographic library is usually broken, not by a direct attack on the underlying algorithm, RSA although quite dated is still secure, but through other means like buffer overflows, cache timing attacks and other <em>side channel</em> attacks. How can one minimise this? Let me give an example of a code which, while correct in normal circumstances, is bad in a crypto setting. Suppose you grant privileged access to a user by comparing a secret that you posses with the user supplied password. A naive string comparison will be prone to timing attacks: The time taken to reject a password is proportional to length of the longest common prefix of the secret and the password. The attacker then can guess the password one character at a time by looking at the time it takes for you to reject the password. One would usually not compare the secrets directly but hash them together with a salt and compare the hashes. However, any comparisons that take time <em>dependent</em> on the user input is prone to lead to future attacks when deployed without much thought.</p>
<p>We could avoid this problem by asking users of our library to always use string comparisons that take constant time irrespective of the input. However, it is very likely that a user of our library, most of them will not be cryptographers, might miss this instruction. Won’t it be nice if such incidents are caught at compile time?</p>
<p>We avoid this problem in <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> by leveraging its type safety. Instead of representing cryptographically significant data types like hashes, macs etc. as mere byte string, we define <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> data types for them. For example sha1 hashes are represented (in a simplified form) as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">
<span class="kw">module</span> <span class="dt">Raaz.Hash.Sha1</span> ( <span class="dt">Sha1</span> )

<span class="kw">data</span> <span class="dt">Sha1</span> <span class="fu">=</span> <span class="dt">Sha1</span> <span class="dt">Word32</span> <span class="dt">Word32</span> <span class="dt">Word32</span> <span class="dt">Word32</span> <span class="dt">Word32</span>

<span class="kw">instance</span> <span class="dt">Eq</span> <span class="dt">Sha1</span> <span class="kw">where</span>
	(<span class="fu">==</span>) (<span class="dt">Sha1</span> h0 h1 h2 h3 h4) (<span class="dt">Sha1</span> g0 g1 g2 g3 g4)
             <span class="fu">=</span>   xor h0 g0
             <span class="fu">.|.</span> xor h1 g1
             <span class="fu">.|.</span> xor h2 g2
             <span class="fu">.|.</span> xor h3 g3
             <span class="fu">.|.</span> xor h4 g4
             <span class="fu">==</span> <span class="dv">0</span></code></pre></div>
<p>The <code>Eq</code> instance for Sha1 has comparison operator defined in such a way that it will take time independent on the number of positions they match. A user is then forced by the compiler to use this equality as we will not be exposing the constructor to her.</p>
<h1 id="status-of-the-project-and-how-to-contribute">Status of the project and how to contribute</h1>
<p>Currently we have just began. We have made no releases yet and we are still experimenting with the API. All code is available under BSD3 license from <a href="http://github.com/raaz-crypto/raaz" class="uri">http://github.com/raaz-crypto/raaz</a>).</p>
<p>I look forward to your contributions. Even if you are not comfortable with haskell, you can contribute. For example, if computer architecture is your bread and butter and you are the <a href="http://en.wikipedia.org/wiki/Chuck_Norris" title="Wikipedia: Chuck Norris">Chuck Norris</a> of assembly language programming, do join us for some fun coding: A lot of primitives require fast implementation often exploiting the platform specific features like <a href="http://en.wikipedia.org/wiki/SIMD" title="Wikipedia: SIMD">SIMD</a> instruction set.</p>]]></summary>
</entry>
<entry>
    <title>Comments on this blog.</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-05-22-Comments-on-this-blog.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-05-22-Comments-on-this-blog.html</id>
    <published>2013-05-22T00:00:00Z</published>
    <updated>2013-05-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This blog does not support comments. The reasons are the following</p>
<ol style="list-style-type: decimal">
<li><p>This is a static using no dynamic PHP or any such monstrosities. I could have something like <a href="http://disqus.com">Disqus</a>.</p></li>
<li><p>I am already full with spams in my inbox and do not have the motivation like others to weed out the spam.</p></li>
</ol>
<p>However if you are motivated, and feel that <a href="http://xkcd.com/386" title="Duty Calls">some one is wrong on the internet</a>, then you can send your comments to me via email. I hope to make the source code of this site open to all. Once that happens you can also send patches to me which will be incorporated.</p>
<p><strong>Update 28 May 2013:</strong> The entire hakyll source is available at <sub><del><a href="http://hub.darcs.net/ppk/website" class="uri">http://hub.darcs.net/ppk/website</a></del></sub> <a href="http://github.com/piyush-kurur-pages/website" class="uri">http://github.com/piyush-kurur-pages/website</a></p>
<p><strong>Update 03 Oct 2013:</strong> Now uses disqus for commenting.</p>]]></summary>
</entry>
<entry>
    <title>Webpage Reloaded</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2013-05-15-Webpage-Reloaded.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2013-05-15-Webpage-Reloaded.html</id>
    <published>2013-05-15T00:00:00Z</published>
    <updated>2013-05-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is my very first post. It also coincides with the entire rewriting of my homepage and these two events are not independent. I used to use a set of Makefiles for dependency checks, <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> for generating html, m4 for templating and no css. The stuff worked but it soon became difficult to maintain.</p>
<p>It was more or less clear to me from the start that I wanted a static site managed via <a href="http://darcs.net" title="Darcs">darcs</a>, written in <a href="http://daringfireball.net/projects/markdown/" title="Markdown">markdown</a>. Of course there is <a href="http://jekyllrb.com" title="Jekyll">jekyll</a> but I always thought <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> was way more powerful than some of the other markdown processors that comes with <a href="http://jekyllrb.com" title="Jekyll">jekyll</a>. And then I heard of <a href="http://jaspervdj.be/hakyll/" title="Hakyll">hakyll</a>. It uses <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> as its markdown processor which means that I get all the <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> goodies: easy math integration, syntax highlighting, and possibility of using different input (say latex) and output (say pdf) formats. Besides, it is written in <a href="http://www.haskell.org" title="Haskell homepage">my favorite programming language</a>. No more excuses for a bad homepage.</p>
<p>I <em>never</em> thought my page would ever be styled with css. As a language (if you can call it one) css is pretty lousy, maybe slightly better than html. Besides, no two browser seems to agree on the standard. Who, in their right senses would want to work with it ? <a href="http://compass-style.org" title="Compass">Compass</a> made me change my opinion. Firstly, you can use the <a href="http://sass-lang.com" title="Sass">sass</a> now instead of css, an advantage comparable to using <a href="http://daringfireball.net/projects/markdown/" title="Markdown">markdown</a> instead of html. Secondly, it has mixins that take care of all (most) of those browser incompatibilities. It might not go well with IE users: I don’t know, neither do I care to know. But it should work mostly. The style for this page is entirely written in sass using the <a href="http://compass-style.org" title="Compass">compass</a> framework. I will publish the source code soon after some refactoring.</p>
<p>Thanks to the great softwares mentioned above, I now have a clean homepage complete with a blog and atom/rss feeds. Some lecture notes that I had are not yet hakyllised. It will soon be.</p>
<p>A big <em>thank you</em> to the folks behind <a href="http://jaspervdj.be/hakyll/" title="Hakyll">hakyll</a>, <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> and <a href="http://compass-style.org" title="Compass">compass</a>.</p>
<p><strong>Update 18 May 2013</strong>: I have added my old wrtings as blog post. So it might appear as if this not my first post.</p>]]></summary>
</entry>
<entry>
    <title>Why kick Elsevier?</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2012-02-20-Why-Kick-Elsevier.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2012-02-20-Why-Kick-Elsevier.html</id>
    <published>2012-02-20T00:00:00Z</published>
    <updated>2012-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This is my understanding of the issue. You are free to send me any correction.</p>
<h2 id="economic-damage">Economic damage</h2>
<ol style="list-style-type: decimal">
<li><p>High cost of journal subscription. Journals of Elsevier are too costly. What is worse is that they have taken over other journals and currently have a huge monopoly.</p></li>
<li><p>Bundling journals. Libraries have to subscribe to a bundle to get a few journals of interest. Often bundles contain journals that are not of any interest to a particular institution. Worse, they include journals which themselves are questionable: e.g. journals like Chaos, Soliton and fractals.</p></li>
</ol>
<h2 id="unethical-publishing-practice">Unethical publishing practice</h2>
<ol style="list-style-type: decimal">
<li><p>Reviewing, which is important scientific responsibility of any journals, have been a sham in many cases. For example, Journals like Chaos, Soliton and fractals have published 302 papers from their Editor-in-chief El Naschie. (See <a href="http://rationalwiki.org/wiki/Mohamed_El_Naschie" class="uri">http://rationalwiki.org/wiki/Mohamed_El_Naschie</a>)</p></li>
<li><p>Setting up journals on pseudo-sciences like for e.g. The Homeopathy (No link given so that they don’t get the benefit of page ranking) which give them unnecessary scientific credibility. Astrologers, What are you waiting for? Call Elsevier right now.</p></li>
<li><p>There has been cases of Elsevier publishing many fake papers written by ghost writers in return to getting paid by drug companies. See for example</p>
<ul>
<li><a href="http://classic.the-scientist.com/blog/display/55671/">The Scientist article on Merck affair</a></li>
<li><a href="http://www.cbsnews.com/8301-505123_162-42842372/elsevier-accused-again-in-ghostwriting-scandal---this-time-in-wyeth-prempropremarin-cases/">They do it again</a></li>
</ul></li>
<li><p>Reed Elsevier’s role in arms trade (See <a href="http://www.idiolect.org.uk/elsevier/" class="uri">http://www.idiolect.org.uk/elsevier/</a>) While an action that is difficult to justify, I would not consider this hurting the scientific publishing directly (other than the <em>minor</em> danger of completely wiping out humanity and thus the scientific establishment, at least on earth). With pressure mounting, apparently they have given up on this illustrious business.</p></li>
</ol>
<p>Summarising, the business practice of Elsevier has hurt scientific foundation not only economically but also led to lose of scientific credibility due to the questionable publishing standards they have followed.</p>
<h1 id="what-can-we-do">What can we do ?</h1>
<ol style="list-style-type: decimal">
<li><p>Boycott them. See <a href="http://thecostofknowledge.com" class="uri">http://thecostofknowledge.com</a>.</p></li>
<li><p>If you are an editor of an Elsevier journal, resign now and encourage your fellow editors to resign en masse. See</p>
<ul>
<li><a href="http://www.cs.colorado.edu/~hal/jalg.html"><em>Journal of Algorithms</em> editorial board resignation</a></li>
<li><a href="http://math.ucr.edu/home/baez/topology-letter.pdf">Resignation of the editorial board of <em>Topology</em></a></li>
</ul></li>
<li><p>If you happen to be in the library committee of your institute try to get Elsevier out of the subscription list.</p></li>
<li><p>Support and form journals like <a href="http://theoryofcomputing.org"><em>Theory of Computing</em></a></p></li>
<li><p>Make all your work available on the net.</p></li>
</ol>
<p>Remember all of this is not without ``risks’’. So evaluate the best options for you and make up your mind.</p>]]></summary>
</entry>
<entry>
    <title>SSHFS: Remote directory over ssh</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2011-06-03-SSHFS-Remote-directory-over-ssh.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2011-06-03-SSHFS-Remote-directory-over-ssh.html</id>
    <published>2011-06-03T00:00:00Z</published>
    <updated>2011-06-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Often one wants shared access to files across machines. Traditionally one uses the <a href="http://en.wikipedia.org/wiki/Network_File_System_(protocol)" title="NFS Wiki">network file system</a> (<a href="http://en.wikipedia.org/wiki/Network_File_System_(protocol)" title="NFS Wiki">nfs</a>). The network file server works as follows: There is an <em>nfs server</em> that <em>exports</em> some directories in its filesystem hiearchy to various <em>nfs clients</em> that <em>mount</em> these directory over the network into their file system hierarchy. As a result, each of the clients shares the directories exported by the nfs server. However <a href="http://en.wikipedia.org/wiki/Network_File_System_(protocol)" title="NFS Wiki">nfs</a> is probably the worst protocol when it comes to security and is rightly called network failure system.</p>
<p>This is a tutorial on sshfs or ssh file system. The idea is to provide a <a href="http://en.wikipedia.org/wiki/Network_File_System_(protocol)" title="NFS Wiki">nfs</a> like mount which is secured by the very dependable ssh (the sftp subsystem of ssh).</p>
<h1 id="using-sshfs.">Using sshfs.</h1>
<ol style="list-style-type: decimal">
<li>First mount the remote directory onto a local directory</li>
</ol>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="ex">sshfs</span> ppk@remote: path/to/mount</code></pre></td></tr></table></div>
<p>where <code>path/to/mount</code> is the point where you want the remote file system to be mounted.</p>
<ol start="2" style="list-style-type: decimal">
<li>After step 1, <code>path/to/mount</code> on your local machine is actually the home directory of the remote machine. So you can use it just like a local machine. Expect slow response if your network connection to remote machine is slow though.</li>
</ol>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">$ <span class="bu">cd</span> path/to/mount
$ <span class="ex">emacs</span> myfavoritprogram.hs
$ <span class="ex">ghc</span> myfavoritprogram.hs</code></pre></td></tr></table></div>
<ol start="3" style="list-style-type: decimal">
<li>After you are done with the work on the remote machine you may unmount the file system</li>
</ol>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="ex">fusermount</span> -u path/to/mount</code></pre></td></tr></table></div>
<h1 id="how-it-works.">How it works.</h1>
<p>Sshfs is a userspace file system (fuse) that works over ssh, or rather sftp. Fuse is an implementation of filesystem primitives in userspace rather than in kernel space. This essentially means that users can mount and unmount file system without having to be root. Sshfs makes use of the sftp subsystem to do the remote file system operations. Thus all the great features of ssh holds true, i.e. key based authentication, use of ssh-agents. See my <a href="../posts/2011-06-02-SSH-A-quick-guide.html">tutorial blog on ssh</a> for more details on how to use ssh.</p>
<h1 id="installing-sshfs.">Installing sshfs.</h1>
<p>All linux distros have a prebuilt package for sshfs. On <a href="http://www.debian.org" title="Debian">Debian</a>/<a href="http://www.ubuntu.com" title="Ubuntu">Ubuntu</a> and <a href="http://www.archlinux.org" title="The Arch Linux homepage">Arch</a> the relevant package is <code>sshfs</code>. So all you need to do is to install it.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="ex">aptitude</span> install sshfs <span class="co"># as root.</span>
$ <span class="fu">sudo</span> aptitude install sshfs <span class="co"># if you are on Unbutu</span>
$ <span class="ex">pacman</span> -S sshfs <span class="co"># as root on an Arch machine</span></code></pre></td></tr></table></div>
<p>On Fedora it looks like it is called <code>fuse-sshfs</code> so something like this should work.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">$ <span class="ex">yum</span> install fuse-sshfs</code></pre></td></tr></table></div>
<h1 id="ssh-is-working-but-not-sshfs.">Ssh is working but not sshfs.</h1>
<p>A common error that people have reported is that ssh works but sshfs fails. If this happens, check whether your sftp subsystem is working. Most probably this too would fail or work incorrectly. One of the main reasons why sshfs/sftp does not work is because your startup scripts in the remote machine prints stuff on the screen. To check this out, try the following command.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">$ <span class="fu">ssh</span> ppk@remote /bin/true</code></pre></td></tr></table></div>
<p>If this command produces any output then you are in trouble. You have to fix your startup script in your remote machine — <code>.bash_profile</code> and <code>.bashrc</code>, if you are using bash as your default shell. The startup script should check whether the standard output is a terminal before it outputs something. For this protect your output generating commands inside a <code>test -t 1</code> block as follows</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">$ <span class="fu">cat</span> .bash_profile

<span class="kw">if</span><span class="bu"> [</span> <span class="ot">-t</span> 1<span class="bu"> ]</span> <span class="co"># Check if stdout is connected to a terminal</span>
<span class="kw">then</span>
    <span class="bu">echo</span> <span class="st">&quot;The answer is 42&quot;</span>
<span class="kw">fi</span></code></pre></td></tr></table></div>
<p>See the <a href="http://www.openssh.com/faq.html" title="ssh faq">openssh FAQ</a> for more details.</p>]]></summary>
</entry>
<entry>
    <title>SSH: A quick guide</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2011-06-02-SSH-A-quick-guide.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2011-06-02-SSH-A-quick-guide.html</id>
    <published>2011-06-02T00:00:00Z</published>
    <updated>2011-06-02T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>The secure shell or <em>ssh</em> is much more than a secure replacement for telnet. Using ssh is not only secure but also convenient. We will have a look at ssh in this article. The objective is not to explain all the features of ssh, for that you can consult the man page, but to examine some of the key features and their use. All the code in this poset should work if you cut and paste (without the <code>$</code> prompt of course) it on to the terminal. Also by ssh I mean <a href="http://www.openssh.com" title="OpenSSH homepage">openssh</a> throughout.</p>
<h2 id="your-.ssh-directory">Your .ssh directory</h2>
<p>All the files used by ssh are inside the .ssh directory in your home area. Here is a list of them and their use.</p>
<ul>
<li>known_hosts: This file contains the public keys of some of the hosts that you have logged in to.</li>
<li>id_rsa: <a href="http://en.wikipedia.org/wiki/RSA" title="RSA Wiki">RSA</a> private key.</li>
<li>id_rsa.pub: <a href="http://en.wikipedia.org/wiki/RSA" title="RSA Wiki">RSA</a> public key.</li>
<li>id_dsa: <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm" title="DSA Wiki">DSA</a> private key.</li>
<li>id_dsa.pub: <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm" title="DSA Wiki">DSA</a> public keys.</li>
<li>authorized_keys: List of public keys of users who are authorised to access this account.</li>
</ul>
<h2 id="managing-known_hosts">Managing known_hosts</h2>
<p>The known_hosts file contains the public keys of all the hosts that you have logged in to. It is a good idea to get these known hosts from a trusted source. When your ssh client contacts a server, it receives public key of the server. If there is a mismatch, ssh warns you that the key has changed. This could be due to a man-in-the-middle attack or due to a system reinstallation. When you get such a message it is better to be sure that there is no tampering. Be especially careful if you in an unknown LAN or WiFi network like that of an airport or a hotel. Having a trusted known_hosts file is a very good security measure.</p>
<h2 id="key-based-login.">Key based login.</h2>
<p>Usually one uses ssh with passwords to login. Although this is secure in the sense that the passwords sent are encrypted, it has all the problems of password based authentication. An alternative is to use public key/private key based authentication. The public key access is more secure and in fact more convenient than the password based access. Here is the step by step procedure.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh-keygen</span> <span class="co"># Generate the public key/private key pair.</span></code></pre></td></tr></table></div>
<p>You will find the generated keys inside the .ssh directory. The files with extension .pub are the public keys. Copy them into the .ssh/authorized_keys file of the remote machine.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
7
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">$ <span class="fu">scp</span> .ssh/id_rsa.pub @remote:
$ <span class="fu">ssh</span> remote
<span class="ex">ppk@remote</span>: mkdir .ssh
<span class="ex">ppk@remote</span>: cat id_rsa.pub <span class="op">&gt;&gt;</span> .ssh/authorized_keys
               <span class="co"># copy the key to the authorized_keys file.</span>
<span class="ex">ppk@remote</span>: chmod 644 .ssh/authorized_keys
               <span class="co"># Ensure that it is readable only to user.</span></code></pre></td></tr></table></div>
<p>The last step is particularly important. Ssh will refuse to login if it finds that the .ssh/authorized_keys is writeable to someone other than the user. Otherwise an intruder could leave his public key and will have unrestricted access. So do not forget to change permissions. Many have been stumped by this and ssh does not give any indication on where the problem is.</p>
<p>In case you connect to many hosts it is a good idea to install the same public key in all the different hosts you log into. Thus you need to remember only one passphrase for all these hosts.</p>
<h2 id="generating-keys-from-a-windows-machine">Generating keys from a Windows machine</h2>
<p>Of course the best option is to install yourself an operating system, one of the BSD’s or GNU/Linuxes for example. However if you don’t have that option, you will also be forced to use other ssh clients like putty. My experience with these clients are limited and that prevents me from giving a detailed procedure. Usually they have a click-click interface to generate keys. The keys generated are however not in the format expected by by openssh. Don’t you worry. The correct format is only a command line away.</p>
<p>As before you have to copy the public key to the remote machine. The command</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh-keygen</span> -i -f pubkeyfile</code></pre></td></tr></table></div>
<p>will convert an SSH2 compatible key format, which is what many of the commercial ssh-client uses, to openssh compatible key format and print it on the standard output. So after copying the public key to the remote machine, you can type</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh-keygen</span> -i -f pubkeyfile <span class="op">&gt;&gt;</span> .ssh/authorized_keys</code></pre></td></tr></table></div>
<p>on the remote machine.</p>
<h2 id="passphrase-empty-passphrase-and-ssh-agents.">Passphrase, Empty Passphrase and SSH-agents.</h2>
<p>While generating a public key/private key pair one is asked for a passphrase. The passphrase is used to keep you private key encrypted on the disk. It is never sent across the network or used in the protocol. Thus one can use an empty passphrase in which case the private key is kept unencrypted on the disk. In case your machine is a private laptop this is not such a bad idea. The advantage of an empty passphrase is that you will never have to type any passwords while ssh-ing or scp-ing. However there is always a risk of your private key getting compromised if the local machine from which you log on to the remote machine is a shared machine. You could, for example, forget to logout from the common terminal. So it is a good idea to have a passphrase.</p>
<p>A better alternative to an empty passphrase is to use an ssh-agent. The ssh-agent keeps you private key with it and does all authentication on your behalf. Here is a quick example.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
4
5
6
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh-agent</span> bash  <span class="co"># start a new shell session with an ssh-agent running</span>
$ <span class="fu">ssh-add</span>         <span class="co"># add your public keys to the agent.</span>
$ <span class="fu">ssh</span> remote      <span class="co"># No passphrase will be asked</span>
<span class="ex">ppk@remote</span>: exit
$ <span class="fu">scp</span> foo ppk@remote:  <span class="co"># No passphrase will be asked.</span></code></pre></td></tr></table></div>
<p>I like to use ssh-agent in conjunction with screen (another cute program). This is what I do.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh-agent</span> screen <span class="co"># start a screen session with an ssh-agent</span>
$ <span class="fu">ssh-add</span>          <span class="co"># in any of the windows of the screen.</span></code></pre></td></tr></table></div>
<p>Now no passwords are asked in any of the windows of the screen session. Usually I leave my screen session running in the office machine (which is physically secure as only I have the key to my office) and when I connect from home, I attach my self to the already running screen in my office machine.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
<span class="ex">ppk@home</span>: ssh office
<span class="ex">ppk@office</span>: screen -x  <span class="co"># connect to the already running screen</span></code></pre></td></tr></table></div>
<p>When I am done I detach the screen. Thus one can go on for months without typing any passphrase for any of the ssh/scp/sftp sessions.</p>
<h2 id="ssh-tunneling-or-port-forwarding.">SSH-tunneling or port forwarding.</h2>
<p>One of the most powerful uses of ssh is its ability to <em>port forward</em>. You can build an <em>ssh tunnel</em> and connect a local port to a remote port. For all purpose this local port is the remote port. For example suppose there is an smtp server (mail server) running on remote which relays mails only from remote. You can set up a tunnel that connects your local port with that of the remote smtp port provided you have shell access to the remote host. Here is how you do it.</p>
<div class="sourceCode"><table class="sourceCode bash numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode bash">
$ <span class="fu">ssh</span> -N -L 2500:remote:25 ppk@remote <span class="kw">&amp;</span></code></pre></td></tr></table></div>
<p>Now you have a smtp server “running” at port 2500 of your machine. All the traffic to port 2500 is redirected via the ssh tunnel to the port 25 of the remote machine. If you want to actually forward the port 25 of you local machine, you need to be root on your local machine as this is a privileged port. However you don’t need root access on remote.</p>
<p>Using tunnel devices and ssh port forwarding one can also setup vpn like network. We wont go into the details in this article.</p>]]></summary>
</entry>
<entry>
    <title>Markdown: or how I stopped hating html and started liking homepage creation</title>
    <link href="http://cse.iitk.ac.in/users/ppk/posts/2010-04-13-Markdown.html" />
    <id>http://cse.iitk.ac.in/users/ppk/posts/2010-04-13-Markdown.html</id>
    <published>2010-04-13T00:00:00Z</published>
    <updated>2010-04-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>It was hate at first sight. I remember quite well my first encounter with <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a>. It was way back in the previous century (somewhere around 1997-98) when I first saw an actual <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> page. It looked uglier than the <em>DO 10 CONTINUE</em> lines of Fortran 77 that we were forced to use as part of our B.Tech “Learn how to use a computer” course. Many of my friends considered this Fortran course as part of the “Ragging” that one has to endure to become Engineers. But I am sure when they started their webpage creating phase of life they would have come for an even bigger shock. To put it politely: <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> is an ugly format that has caused more miseries to humanity than all the world’s religions put together.</p>
<p>The popularity of <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> is baffling. It is not the most efficient of the formats from the rendering point of view and definitely not a format for mere mortals. The kludge called <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> also brought about an industry of WYSIWYG <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> editors which really spits venom when asked to render a Hello world page. This has lead to many “Best view by …. under 1024 x 798 resolution” pages; so much for the “portability” of <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a>. Despite all these shortcomings <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> became popular. What more its “success” as a text format lead people to the creation of even uglier cousins like <a href="http://www.w3.org/XML/" title="XML Homepage">XML</a>.</p>
<p>In this difficult world I had to make my homepage. Having a homepage is important in today’s world, they say. It is important to have your papers online, for example, in the unlikely event that some one is interested in your work. But the ugliness of <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> was unbearable. I searched far and low for other ways to create <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> including <a href="http://www.latex2html.org" title="LaTeX to HTML homepage">LaTeX2HTML</a>. All had their drawbacks.</p>
<p>Enter <a href="http://daringfireball.net/projects/markdown/" title="Markdown">Markdown</a>. This really changed my life as far as webpage creation is concerned. Here is a format that one can easily convert to <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a> and is as pleasing to write as an anonymous hate mail to your boss (<a href="http://daringfireball.net/projects/markdown/" title="Markdown">markdown</a>’s format is based on email conventions). To convert markdown to html one just uses the <a href="http://daringfireball.net/projects/downloads/Markdown_1.0.1.zip" title="Markdown.pl">markdown.pl</a> script. However my favourite converter is the swiss army knife for format conversion <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a>. <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">Pandoc</a> is a program that can inter convert between various text formats much like the <a href="http://www.imagemagick.org/script/convert.php" title="ImageMagick convert">convert</a> for image formats. This means that if you already have an existing homepage you can use <a href="http://johnmacfarlane.net/pandoc" title="Pandoc">pandoc</a> to first convert it into <a href="http://daringfireball.net/projects/markdown/" title="Markdown">markdown</a>, edit it and then reconvert to <a href="http://www.w3.org/TR/REC-html40/" title="HTML Reference">html</a>. Pandoc also supports much needed extensions like the inline math a la LaTeX, a horror if one has to do it using <a href="http://www.w3.org/Math/" title="MathML">MathML</a>.</p>
<p><a href="http://johnmacfarlane.net/pandoc" title="Pandoc">Pandoc</a> is not just a text format converter. It comes with a supporting <a href="http://www.haskell.org" title="Haskell homepage">Haskell</a> library which can be used to program specialised converters if needed.</p>]]></summary>
</entry>

</feed>
