<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <meta http-equiv="Content-Style-Type" content="text/css" />
    <meta name="keywords" content="Type theory" />
    
    
    <link rel="prev" href="../posts/2014-01-11-Typed-lambda-calculus.html" />
    
    <meta name="generator" content="pandoc" />
    <link href="//fonts.googleapis.com/css?family=Tangerine:700" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" type="text/css">
    <link href="../stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <link href="../stylesheets/font-awesome/font-awesome.css" media="screen, projection" rel="stylesheet" type="text/css" />
    <title>Piyush P Kurur|Dependent types</title>
  </head>
  <body>
    <div id="root" class="page">
  <div class="header">
    <h1>Piyush P Kurur</h1>
    <div class="navigation">
      <!-- Add your navigation menu here !-->
<ul>
<li><a href="../" title="Home"><i class="fa fa-home"></i></a></li>
<li><a href="../posts/feeds/atom.xml"><i class="fa fa-rss"></i></a></li>
<li><a href="../contact/" title="Contact"><i class="fa fa-envelope"></i></a></li>
<li><a href="https://github.com/piyush-kurur" title="On GitHub"><i class="fa fa-github"></i></a></li>
<li><a href="https://bitbucket.org/piyush-kurur" title="On BitBucket"><i class="fa fa-bitbucket"></i></a> <!--

[<i class="icon-legal " title="Legalese"/>](/legal/)

[<i class="icon-archive " title="Archive"/>](/posts/archive/)
--></li>
</ul>
    </div>
  </div>
  <div class="main-content">
    <span class="post-tags"><i class="fa fa-tags"></i><a href="../posts/tags/Type%20theory.html">Type theory</a></span>
<div class="post">
  <h1 id="post-title">Dependent types</h1>
  <span class="post-date">August 27, 2014 (Wednesday)</span>

  <a href="//www.reddit.com/submit" onclick="window.location = '//www.reddit.com/submit?url=' + encodeURIComponent(window.location); return false" alt="submit to reddit" border="0">
    <span class="reddit">
      <i class="fa fa-reddit-square fa-lg"></i> reddit this
    </span>
  </a>
  <br />
    <p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we looked at simply typed lambda calculus where each term was associated with a type. As such the types of the language and terms were completely separated — we could define the types of the language independent of terms. A dependently typed language is one where the types can depend on values from a given type. For example consider the natural numbers <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ℕ</mi><annotation encoding="application/x-tex">ℕ</annotation></semantics></math>. In a language like Haskell, we can define them inductively. However, what if we want to capture the collection of residue classes <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>n</mi></msub><annotation encoding="application/x-tex">ℕ_n</annotation></semantics></math> modulo a number <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>:</mo><mi>ℕ</mi></mrow><annotation encoding="application/x-tex">n:ℕ</annotation></semantics></math>. Ideally, we would want to distinguish the types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>m</mi></msub><annotation encoding="application/x-tex">ℕ_m</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>ℕ</mi><mi>n</mi></msub><annotation encoding="application/x-tex">ℕ_n</annotation></semantics></math> for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>≠</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">m ≠ n</annotation></semantics></math> — the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x + y</annotation></semantics></math> should lead to a type error if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><msub><mi>ℕ</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">x:ℕ_m</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><msub><mi>ℕ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">y:ℕ_n</annotation></semantics></math>. A dependently typed language can supports construction of such types. For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>, a <em>type family</em> <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a collection of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> one for each <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math>.</p>
<p>In the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>, we saw that the type inference rules of simply typed lambda calculus gave us the rules of natural deduction for (a fragment of) propositional logic via the Curry-Howard isomorphism. To extend this to predicate logic, we would need a dependently typed lambda calculus as we explain now. Recall that we think of types as mathematical statements and elements of that type as proofs of the statements. Therefore, to capture predicates <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>, we need a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> for every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math>, i.e. we need a <em>type family</em> on A. As before, to prove the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> should mean constructing <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">y : P(a)</annotation></semantics></math>.</p>
<p>Given a set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, which in the type theory world becomes a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, we need types that capture the logical formulae <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(x)</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x∈A) P(x)</annotation></semantics></math>. This is done through the dependent sum (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>) and the dependent product (<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>) types respectively.</p>
<h1 id="σ-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-types.</h1>
<p>For a type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and a type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>, the <em>dependent sum type</em> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math> consists of all pairs <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>,</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a,x)</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x : P(a)</annotation></semantics></math>. The motivation is that proving the statement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math> for the set <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> and predicate <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> <em>constructively</em> involves constructing a witness element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> for which <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> is true. What more, in the constructive setting, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math> being true has to be demonstrated by a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">x:P(a)</annotation></semantics></math>. Thus elements of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A}P(a)</annotation></semantics></math> can be thought of as proofs of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math>. Clearly if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A}P(a)</annotation></semantics></math> is not inhabited, then <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈A) P(a)</annotation></semantics></math> is not provable.</p>
<p>The ordinary product type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A × B</annotation></semantics></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∧</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∧ B</annotation></semantics></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) can be seen as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi></mrow><annotation encoding="application/x-tex">\Sigma_{a:A} P</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> is the type family that assigns <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math> to every <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math> in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. We can also define the ordinary sum type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>+</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A + B</annotation></semantics></math> (or <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∨</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A ∨ B</annotation></semantics></math> in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">last post</a>) as the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>x</mi><mo>:</mo><mi>𝔹</mi></mrow></msub><mi>P</mi></mrow><annotation encoding="application/x-tex">Σ_{x:𝔹} P</annotation></semantics></math>, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝔹</mi><annotation encoding="application/x-tex">𝔹</annotation></semantics></math> is the boolean type containing two values <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="normal"><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi></mstyle><annotation encoding="application/x-tex">\mathrm{True}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="normal"><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi></mstyle><annotation encoding="application/x-tex">\mathrm{False}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math> is the type family <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mi>.</mi><mstyle mathvariant="bold"><mi>𝐢</mi><mi>𝐟</mi></mstyle><mspace width="0.278em"></mspace><mi>x</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐡</mi><mi>𝐞</mi><mi>𝐧</mi></mstyle><mspace width="0.278em"></mspace><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐞</mi><mi>𝐥</mi><mi>𝐬</mi><mi>𝐞</mi></mstyle><mspace width="0.278em"></mspace><mi>B</mi></mrow><annotation encoding="application/x-tex">λ x . \mathbf{if}\; x\; \mathbf{then}\;A\;\mathbf{else}\;B</annotation></semantics></math>.</p>
<p>The first component of any element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>z</mi><annotation encoding="application/x-tex">z</annotation></semantics></math> of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math> gives an element of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. For types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> that do not have any inhabitants, it is impossible to construct element in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Σ</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Σ_{a:A} P(a)</annotation></semantics></math>. This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∃</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>∅</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∃(x∈∅) P(x)</annotation></semantics></math> is false.</p>
<h1 id="π-types."><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-types.</h1>
<p>The <em>dependenent product</em> (or the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-type) <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a : A} P(a)</annotation></semantics></math> consists of functions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> whose value <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(a)</annotation></semantics></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">P(a)</annotation></semantics></math>. The motivation from the logical side is that a proposition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>∈</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x∈A)P(x)</annotation></semantics></math> can be proved by giving a function <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>f</mi><annotation encoding="application/x-tex">f</annotation></semantics></math> that takes every element <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">a:A</annotation></semantics></math> to a proof <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo><mo>:</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(a) : P(a)</annotation></semantics></math>. In agda, the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a : A} P(a)</annotation></semantics></math> is denoted by <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo>:</mo><mi>A</mi><mo stretchy="false" form="postfix">)</mo><mo accent="false">→</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(a : A) → P(a)</annotation></semantics></math>.</p>
<p>Dependent type languages gives ways to construct functions in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>a</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>a</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">Π_{a:A}P(a)</annotation></semantics></math> for any empty type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>. For example, if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>:</mo><mi>⊥</mi><mo accent="false">→</mo><mstyle mathvariant="normal"><mi>T</mi><mi>y</mi><mi>p</mi><mi>e</mi></mstyle></mrow><annotation encoding="application/x-tex">P : ⊥ → \mathrm{Type}</annotation></semantics></math> is a type family we can create the function f in agda by using what is known as the <em>absurd pattern</em> (see line 2 below).</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">proof <span class="fu">:</span> (x <span class="fu">:</span> ⊥) <span class="ot">→</span> <span class="dt">P</span>(x) <span class="co">-- this is the dependent Π-type.</span>
proof ()               <span class="co">-- proof is defined using absurd pattern</span></code></pre></td></tr></table></div>
<p>This is in line with the idea that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>∀</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo>:</mo><mi>∅</mi><mo stretchy="false" form="postfix">)</mo><mi>P</mi><mo stretchy="false" form="prefix">(</mo><mi>x</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">∀(x:∅) P(x)</annotation></semantics></math> is true.</p>
<h1 id="the-vector-type-an-example-from-programming.">The <code>Vector</code> type: An example from programming.</h1>
<p>We now give an example of the famous vector type in agda used to captures lists of a particular length.</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
3
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span> <span class="fu">:</span> ℕ <span class="ot">→</span> <span class="dt">Type</span> <span class="kw">where</span>
	[]    <span class="fu">:</span> <span class="dt">Vector</span> <span class="dt">A</span> <span class="dv">0</span>
<span class="ot">	_::</span>_  <span class="fu">:</span> {n <span class="fu">:</span> ℕ} <span class="ot">→</span> (a <span class="fu">:</span> <span class="dt">A</span>) <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> n <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n)</code></pre></td></tr></table></div>
<p>Having defined such a type we can define the function <code>head</code> as follows</p>
<div class="sourceCode"><table class="sourceCode haskell numberLines"><tr class="sourceCode"><td class="lineNumbers"><pre>1
2
</pre></td><td class="sourceCode"><pre><code class="sourceCode haskell">head <span class="fu">:</span> {<span class="dt">A</span> <span class="fu">:</span> <span class="dt">Type</span>} <span class="ot">→</span> <span class="dt">Vector</span> <span class="dt">A</span> (succ n) <span class="ot">→</span> <span class="dt">A</span>
head (<span class="ot">x ::</span> _) <span class="fu">=</span> x</code></pre></td></tr></table></div>
<p>One of the advantages of this definition of <code>head</code> is that it can never be applied to an empty vector. This is because the input type <code>Vector A (succ n)</code> of <code>head</code> can never match with the type of the empty vector <code>Vector A 0</code> and hence will lead to a compile time error.</p>
<h1 id="type-inference-rules.">Type inference rules.</h1>
<p>We now give a sketch of the type inference rules for dependently typed lambda calculus. As before typing any term requires to “know” the type of all the free variables in it. We capture this by judgements of the kind <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">Γ ⊢ e:A</annotation></semantics></math>. However, unlike in the simply typed case, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> might itself have variables embedded in it. So not just the free variables in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> but all free variables that occur in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> should appear in the type assumption. Thus our strategy of defining types independent of terms like in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> will not work; we need to define them hand in hand.</p>
<p>The type assumptions themselves should now be an ordered sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> of assumptions of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> with the added restriction that for any assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> in the sequence <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>, all the variables that appear free in the type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> should themselves be defined in previous assumptions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>. Therefore the order of the assumptions in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> matters and they cannot be treated as mere sets. Such sequences will be called <em>telescopes</em> of type assumptions. Finally, we can form expressions like <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x: A → e</annotation></semantics></math> only if <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is known to be a valid type which in turn depends on the telescope that is effective at that context. The inference rules for dependently typed lambda calculus thus needs to define <em>simultaneously</em> what the valid types, terms, telescopes and type judgements are. This we capture via the following judgements.</p>
<ol style="list-style-type: decimal">
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow><annotation encoding="application/x-tex">e\;\mathbf{term}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is a valid term,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math> is a valid telescope,</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">A\;\mathbf{type}</annotation></semantics></math> which asserts that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a valid type and finally</p></li>
<li><p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">e:A</annotation></semantics></math> which asserts that the term <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>e</mi><annotation encoding="application/x-tex">e</annotation></semantics></math> is of type <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>.</p></li>
</ol>
<p>We use <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ε</mi><annotation encoding="application/x-tex">ε</annotation></semantics></math> to denote the empty telescope. Any judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ \vdash \mathbf{something}</annotation></semantics></math> means that the judgement <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle><annotation encoding="application/x-tex">\mathbf{something}</annotation></semantics></math> is valid under the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p>We write <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ε</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">ε \vdash \mathbf{something}</annotation></semantics></math> as just <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">\vdash \mathbf{something}</annotation></semantics></math> or even <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle><annotation encoding="application/x-tex">\mathbf{something}</annotation></semantics></math>. To reduce a lot of boiler plate, we sometimes drop certain preconditions if it can be deduced from the other preconditions. For example, we drop the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> if we also have a precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>⊢</mo><mstyle mathvariant="bold"><mi>𝐬</mi><mi>𝐨</mi><mi>𝐦</mi><mi>𝐞</mi><mi>𝐭</mi><mi>𝐡</mi><mi>𝐢</mi><mi>𝐧</mi><mi>𝐠</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ ⊢ \mathbf{something}</annotation></semantics></math> latter on.</p>
<!--
  Besides these we have the special type $𝒰$ which we called the
  universe that stands of type of all types. Strictly speaking having
  such a type can make the logic inconsistent (Girard's paradox) but
  for simplicity we assume this.

  $$\frac{}{Γ ⊢ 𝒰\;\mathbf{type}}$$

  In all the above rules $Γ$ is any valid telescope (we have not
  defied what they are yet) and plays no important roles in the above
  rules. In fact, we can ignore $Γ$ and we have essentially just
  defined the types that we had in the previous. Dependent types will
  use these telescopes in a subtle way.

-->
<dl>
<dt><strong>Rules for telescopes</strong></dt>
<dd>The first rule that we have is that an empty sequence is a valid telescope.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow></mrow><mrow><mi>ε</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{}{ε\;\mathbf{telescope}}</annotation></semantics></math></p>
<p>The next inference rule says that we can add an assumption <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">x:A</annotation></semantics></math> at the end of a valid telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> provided it is possible to infer that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type from the telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">\frac{\Gamma\;\mathbf{telescope};\; \Gamma \vdash
  A\;\mathbf{type}}{\Gamma, x:A\;\mathbf{telescope}} x ∉ Γ</annotation></semantics></math></p>
<p>We have slightly abused the notation in the expression of the side conditions <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∉</mo><mi>Γ</mi></mrow><annotation encoding="application/x-tex">x ∉ Γ</annotation></semantics></math> which essentially says that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is <em>fresh</em>, i.e. does not occur in any assumptions of <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math>.</p>
<dl>
<dt><strong>Formation rules for terms</strong></dt>
<dd>This essentially describes the syntax of our language.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>x</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\frac{}{x\;\mathbf{term}},</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msub><mi>e</mi><mn>1</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow><mrow><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><mo>,</mo></mrow><annotation encoding="application/x-tex">\frac{e_1\;\mathbf{term};\;e_2\;\mathbf{term}}
	{e_1e_2\;\mathbf{term}},</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐫</mi><mi>𝐦</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ\;\mathbf{telescope};\; Γ ⊢ A\;\mathbf{type}}{Γ ⊢ λ x : A →
e\;\mathbf{term}}</annotation></semantics></math></p>
<p>The first two are essentially expressing the lambda calculus syntax for variables and application in the form of rules of inference. The last rule, however says that the expression <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">λ x : A → e</annotation></semantics></math> is a valid term only if it is in the context of a telescope <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Γ</mi><annotation encoding="application/x-tex">Γ</annotation></semantics></math> where <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math> is a type.</p>
<dl>
<dt><strong>Formation rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">Π</annotation></semantics></math>-types</strong></dt>
<dd>We have the following rules by which we can form types
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle><mo>;</mo><mspace width="0.278em"></mspace><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>B</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ ⊢ A\;\mathbf{type};\;Γ, x:A \vdash
		B\;\mathbf{type}} {Γ ⊢ Π_{x:A} B\;\mathbf{type}}</annotation></semantics></math></p>
<p>Notice that we omitted the precondition <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ\;\mathbf{telescope}</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><annotation encoding="application/x-tex">Γ,x : A \;\mathbf{telescope}</annotation></semantics></math> as mentioned before.</p>
<dl>
<dt><strong>Rules for type inferences</strong></dt>
<dd>We have a single variable rule followed by the introduction/elimination rules for the <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Π</mi><annotation encoding="application/x-tex">\Pi</annotation></semantics></math>-type.
</dd>
</dl>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐞</mi><mi>𝐥</mi><mi>𝐞</mi><mi>𝐬</mi><mi>𝐜</mi><mi>𝐨</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>A</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ, x : A\;\mathbf{telescope}}{Γ,x : A ⊢ x : A}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi><mspace width="0.278em"></mspace><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>A</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><msub><mi>e</mi><mn>2</mn></msub><mo>:</mo><mi>B</mi><mo stretchy="false" form="prefix">[</mo><mi>x</mi><mi>/</mi><msub><mi>e</mi><mn>2</mn></msub><mo stretchy="false" form="postfix">]</mo></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ ⊢ e_1 : Π_{x : A} B\; Γ ⊢ e_2 : A}{Γ ⊢ e_1 e_2 :
B[x/e_2]}</annotation></semantics></math></p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mfrac><mrow><mi>Γ</mi><mo>,</mo><mi>x</mi><mo>:</mo><mi>A</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>B</mi></mrow><mrow><mi>Γ</mi><mo>⊢</mo><mo stretchy="false" form="prefix">(</mo><mi>λ</mi><mi>x</mi><mo>:</mo><mi>A</mi><mo accent="false">→</mo><mi>e</mi><mo stretchy="false" form="postfix">)</mo><mspace width="0.278em"></mspace><mo>:</mo><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow></mfrac><annotation encoding="application/x-tex">\frac{Γ, x : A ⊢ e : B}{Γ ⊢ (λ x : A → e) \; : Π_{x : A} B}</annotation></semantics></math></p>
<p>To incorporate the rules for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Σ</mi><annotation encoding="application/x-tex">Σ</annotation></semantics></math>-types, we need to introduce a dependent pairing primitive and the corresponding pairing operations. We leave this as an exercise.</p>
<!--

$$\frac{Γ ⊢ A\;\mathbf{type};\;Γ, x:A \vdash
		B\;\mathbf{type}} {Γ ⊢ Σ_{x:A} B\;\mathbf{type}}$$
-->
<h1 id="where-are-the-dependent-types">Where are the dependent types?</h1>
<p>The dependently typed language we introduced here is mostly useless in the absence of any interesting types and type families. One strategy would be to introduce each type and type family by hand giving its, formation, introduction and elimination rules. At the very least, we fix a base set of types <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>𝒯</mi><annotation encoding="application/x-tex">𝒯</annotation></semantics></math> and add the formation rule <math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow></mrow><mrow><mi>t</mi><mspace width="0.278em"></mspace><mstyle mathvariant="bold"><mi>𝐭</mi><mi>𝐲</mi><mi>𝐩</mi><mi>𝐞</mi></mstyle></mrow></mfrac><mi>t</mi><mo>∈</mo><mi>𝒯</mi><mi>.</mi></mrow><annotation encoding="application/x-tex">\frac{}{t\;\mathbf{type}} t ∈ 𝒯.</annotation></semantics></math> This will give us all the types described in the <a href="../posts/2014-01-11-Typed-lambda-calculus.html" title="Typed lambda calculus">previous post</a> (once we identify <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Π</mi><mrow><mi>x</mi><mo>:</mo><mi>A</mi></mrow></msub><mi>B</mi></mrow><annotation encoding="application/x-tex">\Pi_{x:A}B</annotation></semantics></math> with <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo accent="false">→</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">A → B</annotation></semantics></math> whenever <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math> is not free in <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>B</mi><annotation encoding="application/x-tex">B</annotation></semantics></math>). To make dependently typed systems more useful actual systems supports construction of user defined types and type families. What these constructions are and what should be the restrictions on them has to be worked out. We defer this topic for the future.</p>
</div>

<div class="post-comments">
  <div id="disqus_thread"></div>
</div>

<script type="text/javascript">
  var disqus_shortname  = 'piyushkurur';  // required: Short name.
  var disqus_url        = 'http://cse.iitk.ac.in/users/ppk/posts/2014-08-27-Dependent-Types.html';
                          // The url of this page
  var disqus_title      = 'Dependent types';      // The title of this post
  var disqus_identifier = '2014-08-27-Dependent-Types';  // The id of this post

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

  </div>
  <div id="powered-by-footer"></div>
</div>
<div id="powered-by">
  Powered by: <a href="http://jaspervdj.be/hakyll">Hakyll</a>,
  <a href="http://compass-style.org"> Compass</a> and
  <a href="http://fontawesome.io"><i class="fa fa-flag"></i> Fontawesome</a>
</div>

  </body>
</html>
